@inproceedings{296790,
  title = {Software Aging},
  booktitle = {Proceedings of 16th International Conference on Software Engineering},
  author = {Parnas, D.L.},
  year = {1994},
  pages = {279--287},
  doi = {10.1109/ICSE.1994.296790},
  keywords = {Aging,Command languages,Embedded software,Engineering profession,Humans,Impedance,Machinery,Mathematics,Product design,Programming profession},
  file = {C:\Users\Karl\Zotero\storage\IFYMKUZC\Parnas - 1994 - Software aging.pdf}
}

@inproceedings{8170137,
  title = {Identifying Software Decays: A System Usage Perspective},
  booktitle = {2017 {{ACM}}/{{IEEE}} International Symposium on Empirical Software Engineering and Measurement ({{ESEM}})},
  author = {Mubin, Ashirul and Kuai, Meng},
  year = {2017},
  month = nov,
  pages = {472--473},
  publisher = {IEEE Computer Society},
  address = {Los Alamitos, CA, USA},
  doi = {10.1109/ESEM.2017.64},
  abstract = {The value of a software product diminishes due to emerging new requirements and gradual changes in system usage patterns over its lifespan, including other direct or indirect impacts from the surrounding environment. Often new requirements or changes cannot be addressed instantly; therefore, the system becomes less effective with incompatible or unused features, gradually degrading the overall value of its services. We term this as software decay. In this paper, we attempt to discover this decay during earlier stages in the usage cycle; and measure it by quantifying its system value based on the access rates of its prime features that are necessary to perform its due services for the intended users.},
  keywords = {Computer science,Correlation,Indexes,Object recognition,Software,Software engineering,Software measurement},
  file = {C:\Users\Karl\Zotero\storage\4B7L9HHN\Mubin und Kuai - 2017 - Identifying software decays a system usage perspective.pdf}
}

@article{alharbiEmpiricalInvestigationRelationship2024,
  title = {An Empirical Investigation of the Relationship between Pattern Grime and Code Smells},
  author = {Alharbi, Maha and Alshayeb, Mohammad},
  year = {2024},
  month = sep,
  journal = {Journal of Software: Evolution and Process},
  volume = {36},
  number = {9},
  pages = {e2666},
  publisher = {John Wiley \& Sons, Ltd},
  issn = {2047-7481},
  doi = {10.1002/smr.2666},
  urldate = {2025-02-03},
  abstract = {The results indicate that, in general, the growth of grime is more likely to co-occur with code smells. Specifically, there is a strong positive association between the growth of pattern grime at the...},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\NM6BC5BZ\Alharbi und Alshayeb - 2024 - An empirical investigation of the relationship between pattern grime and code smells.pdf}
}

@article{almadiInvestigatingViolationsRoles2022,
  title = {{Toward Investigating the Violations Roles of Pattern Grime Occurrence in Software Design Patterns}},
  author = {Almadi, Sara H. S.},
  year = {2022},
  month = jun,
  journal = {The International Conference on Evaluation and Assessment in Software Engineering 2022},
  publisher = {ACM},
  doi = {10.1145/3530019.3535347},
  urldate = {2025-02-03},
  langid = {Undetermined},
  file = {C:\Users\Karl\Zotero\storage\EYTI6U4H\Almadi - 2022 - Toward Investigating the Violations Roles of Pattern Grime Occurrence in Software Design Patterns.pdf}
}

@inproceedings{almadiInvestigatingViolationsRoles2022a,
  title = {{Toward investigating the violations roles of pattern grime occurrence in software design patterns violations roles of pattern grime}},
  author = {Almadi, Sara H.S.},
  year = {2022},
  month = jan,
  publisher = {Association for Computing Machinery},
  address = {Malaysia, Australia},
  abstract = {Design patterns (DPs) are recurring solutions for software design problems. They are recommended and employed for their benefits and impact on software quality. However, the improper extension and implementation of design patterns raise the emergence of accumulating bad smells in DPs structure and behavior. Pattern grime occurrence is one of the bad smells in the design pattern. Grime highly reduces design pattern usability, testability, and adaptability, and even prevents their proper implementation. Despite that, pattern grime occurrence may have many severe violations and impacts on design patterns. For instance, grime occurrence contributes to build-up code smells, violates object-oriented principles, and degenerates pattern quality and code structure. This research focuses on investigating the violations roles of grime occurrence in design patterns and aims to propose a taxonomy for pattern grime violation types, to take the first step to develop a prediction model to detect pattern grime occurrence in the software design pattern. Thus, this research outlines a research project targeting the main research question: "how pattern grime is correlated, and how this might lead to violate design pattern principles, structure, and quality? We plan to answer this question through various stages. First, we investigate the commonalities and variability of pattern grime occurrence on design patterns. Secondly, we identify the types of grime roles violation in DPs to propose a taxonomy of pattern grime violation types. The results of these stages will help to identify a prediction model to predict pattern grime in the software design patterns. {\copyright} 2022 ACM.},
  langid = {unknown},
  keywords = {QA76 Computer software}
}

@article{beladyModelLargeProgram1976,
  title = {A {{Model}} of {{Large Program Development}}},
  author = {Belady, L. and Lehman, M.},
  year = {1976},
  journal = {IBM Systems Journal},
  urldate = {2025-03-05},
  abstract = {Observations made on the development of OS/360 and its subsequent enhancements and releases are discussed and some modeling approaches to organizing these observations are presented. Discussed are observations made on the development of OS/360 and its subsequent enhancements and releases. Some modeling approaches to organizing these observations are also presented.},
  langid = {english},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\NAGU7S6E\\Belady und Lehman - 1976 - A Model of Large Program Development.pdf;C\:\\Users\\Karl\\Zotero\\storage\\QTVG6TZP\\09925fa25fa1cf78a63132ab57cbb33d067042ba.html}
}

@article{boehmSoftwareEngineeringEconomics1984,
  title = {Software {{Engineering Economics}}},
  author = {Boehm, Barry W.},
  year = {1984},
  month = jan,
  journal = {IEEE Transactions on Software Engineering},
  volume = {SE-10},
  number = {1},
  pages = {4--21},
  issn = {1939-3520},
  doi = {10.1109/TSE.1984.5010193},
  urldate = {2025-02-19},
  abstract = {This paper summarizes the current state of the art and recent trends in software engineering economics. It provides an overview of economic analysis techniques and their applicability to software engineering and management. It surveys the field of software cost estimation, including the major estimation techniques available, the state of the art in algorithmic cost models, and the outstanding research issues in software cost estimation.},
  keywords = {Analytical models,Computer programming costs,cost models,Costs,Engineering management,Life estimation,management decision aids,Microeconomics,Power generation economics,Resource management,software cost estimation,software economics,software engineering,Software engineering,software management,Software prototyping,State estimation},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\P8F8CISK\\Boehm - 1984 - Software Engineering Economics.pdf;C\:\\Users\\Karl\\Zotero\\storage\\GAH5JYNL\\5010193.html}
}

@article{borowaLivingTechnicalDebt2021,
  title = {Living {{With Technical Debt}}---{{A Perspective From}} the {{Video Game Industry}}},
  author = {Borowa, Klara and Zalewski, Andrzej and Saczko, Adam},
  year = {2021},
  month = nov,
  journal = {IEEE Software},
  volume = {38},
  number = {6},
  pages = {65--70},
  issn = {1937-4194},
  doi = {10.1109/MS.2021.3103249},
  urldate = {2025-02-17},
  abstract = {Video game development has its own specific nature and problems that differentiate it from general software development. We investigated the influence of these factors in a survey and found a distinct lack of systematic management of technical debt.},
  keywords = {Costs,Finance,Games,Licenses,Management},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\5V58WFCR\\Borowa et al. - 2021 - Living With Technical Debt—A Perspective From the Video Game Industry.pdf;C\:\\Users\\Karl\\Zotero\\storage\\C8D9Z8B8\\9508260.html}
}

@article{brooksNoSilverBullet1987,
  title = {No {{Silver Bullet Essence}} and {{Accidents}} of {{Software Engineering}}},
  author = {{Brooks}},
  year = {1987},
  month = apr,
  journal = {Computer},
  volume = {20},
  number = {4},
  pages = {10--19},
  issn = {1558-0814},
  doi = {10.1109/MC.1987.1663532},
  urldate = {2025-02-19},
  keywords = {Computer industry,Costs,Diseases,Hardware,Industrial accidents,Project management,Roads,Silver,Software engineering,Technological innovation},
  file = {C:\Users\Karl\Zotero\storage\DHLS935P\Brooks - 1987 - No Silver Bullet Essence and Accidents of Software Engineering.pdf}
}

@inproceedings{budlongCommercialMilitarySoftware1984,
  title = {Commercial and Military Software Documentation: Different Steps to a Common Goal},
  shorttitle = {Commercial and Military Software Documentation},
  booktitle = {Proceedings of the {{July}} 9-12, 1984, National Computer Conference and Exposition},
  author = {Budlong, Faye C.},
  year = {1984},
  month = jul,
  series = {{{AFIPS}} '84},
  pages = {389--394},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1499310.1499360},
  urldate = {2025-02-19},
  abstract = {Talking about creativity in software documentation may seem like a paradox, but it exists. Even a functional specification for a new product has an element of creativity: It outlines a product that will require the creative endeavors of several developers over a period of time. Further, user manuals require ingenuity to reduce many complex functions to a series of simple, identifiable steps that the user can understand and follow. Training documents require creativity to develop examples that new users can understand and to reinforce a learning curve that allows the reader to become proficient using a new product. And reference manuals require perseverence to ensure that all functions of the product are defined and explained clearly and concisely.This paper is an overview of the development process for software documentation from concept to initial release. It lists much of the documentation required for each major software development step and compares documentation for commercial projects with that required to meet military project standards.},
  isbn = {978-0-88283-043-8},
  file = {C:\Users\Karl\Zotero\storage\TMDIJH3K\Budlong - 1984 - Commercial and military software documentation different steps to a common goal.pdf}
}

@incollection{clasenUmgangMitKomplexitaet2019,
  title = {{Der Umgang mit Komplexit{\"a}t bei SAP und Bundeswehr -- eine subjektive Betrachtung}},
  booktitle = {{Verwaltung, eGovernment und Digitalisierung: Grundlagen, Konzepte und Anwendungsf{\"a}lle}},
  author = {Clasen, Michael},
  editor = {Schmid, Andreas},
  year = {2019},
  pages = {261--272},
  publisher = {Springer Fachmedien},
  address = {Wiesbaden},
  doi = {10.1007/978-3-658-27029-2_20},
  urldate = {2025-02-11},
  abstract = {Einf{\"u}hrung, Wartung und Betrieb von Anwendungssoftware stellt Organisationen nicht selten vor gro{\ss}e Herausforderungen. Eine Ursache hierf{\"u}r liegt in der hohen Komplexit{\"a}t von Softwareprojekten. Als Antwort auf diese Herausforderungen wurden in den letzten Jahren in Wissenschaft und Praxis neue L{\"o}sungsans{\"a}tze entwickelt, die sich in gewinnorientierten Unternehmen zunehmend durchsetzen, in {\"o}ffentlichen Verwaltungen aber noch eine exotische Ausnahme bilden. Gemeint sind zum einen agile Projektmanagementmethoden wie SCRUM, zum anderen mit dem Label 4.0 gekennzeichnete Ans{\"a}tze der Selbststeuerung. Damit diese modernen Methoden gelingen, bedarf es {\"u}berdurchschnittlich motivierter und informierter Mitarbeiter. Um die richtigen personellen Ressourcen anzulocken und zu h{\"o}chsten Leistungen zu motivieren, m{\"u}ssen Arbeitsatmosph{\"a}re und Verg{\"u}tung im Unternehmen stimmen. Aus der pers{\"o}nlichen Erfahrung des Autors heraus werden die Besonderheiten und Unterschiede zwischen dem Unternehmen SAP und der Bundeswehr dargestellt. Am Ende des Beitrags sind Verbesserungspotenziale abgeleitet, die der {\"o}ffentlichen Verwaltung helfen k{\"o}nnen, die Digitalisierung erfolgreich zu gestalten.},
  isbn = {978-3-658-27029-2},
  langid = {ngerman},
  keywords = {Agilitat,Bundeswehr,SAP,Scrum},
  file = {C:\Users\Karl\Zotero\storage\9B7L828N\Clasen - 2019 - Der Umgang mit Komplexität bei SAP und Bundeswehr – eine subjektive Betrachtung.pdf}
}

@inproceedings{codurEvolutionSoftwareDevelopment2009,
  title = {Evolution of Software Development Standards in the Military Domain and Effects on Software Applications},
  booktitle = {Proceedings of the Joint International and Annual {{ERCIM}} Workshops on {{Principles}} of Software Evolution ({{IWPSE}}) and Software Evolution ({{Evol}}) Workshops},
  author = {Codur, Kemal Burak and Dogru, Ali Hikmet},
  year = {2009},
  month = aug,
  series = {{{IWPSE-Evol}} '09},
  pages = {41--46},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1595808.1595818},
  urldate = {2025-02-07},
  abstract = {System life cycle tends to be longer in military applications, reaching over 30 years in specific examples. Development and maintenance of software contained by these systems are regulated by software development standards. Such standards are being utilized since 1978 in the military domain. During recent decades, these standards evolved along with software engineering concepts. This paper presents progress of software development standards in the military domain, with special emphasis on life cycle of applications. This progress is evolutionary, without radical shifts in contents and concepts. Details of the progress provide an insight to the evolution at a conceptual level. Experimental findings regarding the evolution are presented. The study is concluded with comments on the relation between standards' evolution and software applications.},
  isbn = {978-1-60558-678-6},
  file = {C:\Users\Karl\Zotero\storage\9WN8YLXQ\Codur and Dogru - 2009 - Evolution of software development standards in the military domain and effects on software applicati.pdf}
}

@article{cunninghamWyCashPortfolioManagement1992,
  title = {The {{WyCash}} Portfolio Management System},
  author = {Cunningham, Ward},
  year = {1992},
  month = dec,
  journal = {SIGPLAN OOPS Mess.},
  volume = {4},
  number = {2},
  pages = {29--30},
  issn = {1055-6400},
  doi = {10.1145/157710.157715},
  urldate = {2025-02-17},
  file = {C:\Users\Karl\Zotero\storage\9IMW3SWP\Cunningham - 1992 - The WyCash portfolio management system.pdf}
}

@inproceedings{daleImpactsDesignPattern2014,
  title = {Impacts of Design Pattern Decay on System Quality},
  booktitle = {Proceedings of the 8th {{ACM}}/{{IEEE International Symposium}} on {{Empirical Software Engineering}} and {{Measurement}}},
  author = {Dale, Melissa R. and Izurieta, Clemente},
  year = {2014},
  month = sep,
  pages = {1--4},
  publisher = {ACM},
  address = {Torino Italy},
  doi = {10.1145/2652524.2652560},
  urldate = {2025-02-07},
  abstract = {Method To investigate this problem, we have developed a grime injector to model grime growth, a form of design pattern decay, on Java projects. We use SonarQube's technical debt software to compare the technical debt scores of six di↵erent types of modular grime. These six types can be classified along three major dimensions: strength, scope, and direction. Results We find that the strength dimension is the most important contributor to the quality of a design and that temporary grime results in higher technical debt scores than persistent grime. Conclusion This knowledge helps with design decisions that help manage a project's technical debt.},
  isbn = {978-1-4503-2774-9},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\E8NGET4C\Dale and Izurieta - 2014 - Impacts of design pattern decay on system quality.pdf}
}

@article{eickDoesCodeDecay2001,
  title = {Does {{Code Decay}}? {{Assessing}} the {{Evidence}} from {{Change Management Data}}},
  shorttitle = {Does {{Code Decay}}?},
  author = {Eick, Stephen G. and Graves, Todd L. and Karr, Alan F. and Marron, J. S. and Mockus, Audris},
  year = {2001},
  month = jan,
  journal = {IEEE Trans. Softw. Eng.},
  volume = {27},
  number = {1},
  pages = {1--12},
  issn = {0098-5589},
  doi = {10.1109/32.895984},
  urldate = {2025-03-05},
  abstract = {A central feature of the evolution of large software systems is that change which is necessary to add new functionality, accommodate new hardware, and repair faults becomes increasingly difficult over time. In this paper, we approach this phenomenon, which we term code decay, scientifically and statistically. We define code decay and propose a number of measurements (code decay indices) on software and on the organizations that produce it, that serve as symptoms, risk factors, and predictors of decay. Using an unusually rich data set (the fifteen-plus year change history of the millions of lines of software for a telephone switching system), we find mixed, but on the whole persuasive, statistical evidence of code decay, which is corroborated by developers of the code. Suggestive indications that perfective maintenance can retard code decay are also discussed.},
  file = {C:\Users\Karl\Zotero\storage\UTH3ZPSK\Eick et al. - 2001 - Does Code Decay Assessing the Evidence from Change Management Data.pdf}
}

@article{feitosaCorrelatingPatternGrime2018,
  title = {Correlating {{Pattern Grime}} and {{Quality Attributes}}},
  author = {Feitosa, D. and Ampatzoglou, A. and Avgeriou, P. and Nakagawa, E.Y.},
  year = {2018},
  month = jan,
  journal = {IEEE Access, Access, IEEE},
  volume = {6},
  pages = {23065--23078},
  publisher = {IEEE},
  issn = {21693536},
  doi = {10.1109/ACCESS.2018.2829895},
  urldate = {2025-02-03},
  abstract = {The gang of four design patterns are widely adopted in industry as best practices and their effect on software quality has been long investigated in academia, with both positive and negative consequences being observed. One important parameter that relates to the effect of patterns on quality is the deterioration of pattern instances due to the buildup of artifacts unrelated to the pattern structure. This is called pattern grime and can potentially diminish some of the benefits of using patterns in the first place. In this paper we investigate the relation between pattern grime and three qualities, namely performance, security, and correctness. To this end, we conducted a case study with five industrial projects (approx. 260 000 lines of code) implemented by 16 developers. Our findings suggest a correlation between the accumulation of grime and decreased levels of performance, security, and correctness. Moreover, factors such as the project itself, pattern type and the developer can influence this relation. The obtained results can benefit both researchers and practitioners, as we provide evidence on the accumulation of pattern grime and its correlation to performance, security and correctness, and how different factors affect these correlations.},
  keywords = {Aerospace,Bioengineering,Communication Networking and Broadcast Technologies,Components Circuits Devices and Systems,Computing and Processing,Correlation,Data mining,Degradation,Design patterns,Engineered Materials Dielectrics and Plasmas,Engineering Profession,Fields Waves and Electromagnetics,General Topics for Engineers,Geoscience,industrial case study,Nuclear Engineering,Open source software,pattern grime,Photonics and Electrooptics,Power Energy and Industry Applications,quality attributes,Robotics and Control Systems,Security,Signal Processing and Analysis,Software quality,Software systems,Transportation},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\IZNJ6B83\\Feitosa et al. - 2018 - Correlating Pattern Grime and Quality Attributes.pdf;C\:\\Users\\Karl\\Zotero\\storage\\SMKP3XZY\\Feitosa et al. - 2018 - Correlating Pattern Grime and Quality Attributes.pdf}
}

@article{fowlerRefactoringImprovingDesign,
  title = {Refactoring - {{Improving}} the {{Design}} of {{Existing Code}}},
  author = {Fowler, Martin and Beck, Kent and Brant, John},
  langid = {english}
}

@book{gammaDesignPatternsElements1995,
  title = {Design Patterns: Elements of Reusable Object-Oriented Software},
  shorttitle = {Design Patterns},
  author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John},
  year = {1995},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {USA},
  isbn = {978-0-201-63361-0},
  file = {C:\Users\Karl\Zotero\storage\EUV4BJ3H\articulo.pdf}
}

@inproceedings{gurpDesignErosionProblems2001,
  title = {Design {{Erosion}}: {{Problems}} \& {{Causes}}},
  shorttitle = {Design {{Erosion}}},
  author = {Gurp, J. V. and Bosch, J.},
  year = {2001},
  urldate = {2025-02-07},
  abstract = {Design erosion is a common problem in software engineering. We have found that invariably, no matter how ambitious the intentions of the designers were, software designs tend to erode over time to the point that redesigning from scratch becomes a viable alternative compared to prolonging the life of the existing design. In this paper we illustrate how design erosion works by presenting the evolution of the design of a small software system. In our analysis of this example we show how design decisions accumalate and become invalid because of new requirements. Also it is argued that even an optimal strategy for designing the system (i.e. no compromises with respect to e.g. cost are made) does not lead to an optimal design because of unforseen requirement changes that invalidate design decisions that once were optimal.},
  file = {C:\Users\Karl\Zotero\storage\S2KS5F3R\Gurp and Bosch - 2001 - Design Erosion Problems & Causes.pdf}
}

@misc{ImpactsDesignPattern,
  title = {Impacts of Design Pattern Decay on System Quality {\textbar} {{Request PDF}}},
  journal = {ResearchGate},
  doi = {10.1145/2652524.2652560},
  urldate = {2025-02-07},
  abstract = {Request PDF {\textbar} Impacts of design pattern decay on system quality {\textbar} Context Software systems need to be of high enough quality to enable growth and stability. Goal The purpose of this research is to study the... {\textbar} Find, read and cite all the research you need on ResearchGate},
  howpublished = {https://www.researchgate.net/publication/266661826\_Impacts\_of\_design\_pattern\_decay\_on\_system\_quality},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\ZKRCATNC\266661826_Impacts_of_design_pattern_decay_on_system_quality.html}
}

@misc{InvestigatingViolationsRoles,
  title = {Toward {{Investigating}} the {{Violations Roles}} of {{Pattern Grime Occurrence}} in {{Software Design Patterns}}},
  journal = {OpenAIRE - Explore},
  urldate = {2025-02-03},
  abstract = {Toward Investigating the Violations Roles of Pattern Grime Occurrence in Software Design Patterns},
  howpublished = {https://explore.openaire.eu/search/publication?pid=10.1145\%2F3530019.3535347},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\XBZVZI4Z\publication.html}
}

@article{izurietaHowSoftwareDesigns2007,
  title = {How {{Software Designs Decay}}: {{A Pilot Study}} of {{Pattern Evolution}}},
  shorttitle = {How {{Software Designs Decay}}},
  author = {Izurieta, Clemente and Bieman, James M.},
  year = {2007},
  month = sep,
  journal = {First International Symposium on Empirical Software Engineering and Measurement (ESEM 2007), Empirical Software Engineering and Measurement, 2007. ESEM 2007. First International Symposium on},
  pages = {449--451},
  publisher = {IEEE},
  issn = {978-0-7695-2886-1},
  doi = {10.1109/ESEM.2007.55},
  urldate = {2025-02-03},
  abstract = {A common belief is that software designs decay as systems evolve. This research examines the extent to which software designs actually decay by studying the aging of design patterns in successful object oriented systems. Aging of design patterns is measured using various types of decay indices developed for this research. Decay indices track the internal structural changes of a design pattern realization and the code that surrounds the realization. Hypotheses for each kind of decay are tested. We found that the original design pattern functionality remains, and pattern decay is due to the "grime", non-pattern code, that grows around the pattern realization.},
  keywords = {Aging,Computer science,Computing and Processing,Cost function,Decay,Evolution,Open source software,Open Source Software,Permission,Software,Software design,Software engineering,Software Engineering,Software Grime Buildup.,Software measurement,Software systems,Testing},
  file = {C:\Users\Karl\Zotero\storage\FMFX53GV\Izurieta und Bieman - 2007 - How Software Designs Decay A Pilot Study of Pattern Evolution.pdf}
}

@article{izurietaMultipleCaseStudy2013,
  title = {A Multiple Case Study of Design Pattern Decay, Grime, and Rot in Evolving Software Systems},
  author = {Izurieta, Clemente and Bieman, James M.},
  year = {2013},
  month = jun,
  journal = {Software Quality Journal},
  volume = {21},
  number = {2},
  pages = {289--323},
  publisher = {Springer US},
  address = {Boston},
  issn = {09639314},
  doi = {10.1007/s11219-012-9175-x},
  abstract = {Software designs decay as systems, uses, and operational environments evolve. Decay can involve the design patterns used to structure a system. Classes that participate in design pattern realizations accumulate grime---non-pattern-related code. Design pattern realizations can also rot, when changes break the structural or functional integrity of a design pattern. Design pattern rot can prevent a pattern realization from fulfilling its responsibilities, and thus represents a fault. Grime buildup does not break the structural integrity of a pattern but can reduce system testability and adaptability. This research examined the extent to which software designs actually decay, rot, and accumulate grime by studying the aging of design patterns in three successful object-oriented systems. We generated UML models from the three implementations and employed a multiple case study methodology to analyze the evolution of the designs. We found no evidence of design pattern rot in these systems. However, we found considerable evidence of pattern decay due to grime. Dependencies between design pattern components increased without regard for pattern intent, reducing pattern modularity, and decreasing testability and adaptability. The study of decay and grime showed that the grime that builds up around design patterns is mostly due to increases in coupling.{$<$}br /{$>$}},
  langid = {english},
  keywords = {Decay,Design concepts,Design patterns,Grime,Multiple case study,Object-oriented design methods,Software evolution,Technical debt},
  file = {C:\Users\Karl\Zotero\storage\LQBVGR7J\Izurieta und Bieman - 2013 - A multiple case study of design pattern decay, grime, and rot in evolving software systems.pdf}
}

@inproceedings{kitchenhamSystematicReviewSoftware2012,
  title = {Systematic Review in Software Engineering: Where We Are and Where We Should Be Going},
  shorttitle = {Systematic Review in Software Engineering},
  booktitle = {Proceedings of the 2nd International Workshop on {{Evidential}} Assessment of Software Technologies},
  author = {Kitchenham, Barbara A.},
  year = {2012},
  month = sep,
  series = {{{EAST}} '12},
  pages = {1--2},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/2372233.2372235},
  urldate = {2025-02-19},
  abstract = {In 2004 Kitchenham et al. first proposed the idea of evidence-based software engineering (EBSE). EBSE requires a systematic and unbiased method of aggregating empirical studies and has encouraged software engineering researches to undertake systematic literature reviews (SLRs) of Software Engineering topics and research questions. As software engineers began to use the SLR technology, they also began to comment on the SLR process itself. Brereton et al (2007) was one of the first papers that commented on issues connected with performing SLRs and many such papers have followed since covering topics such as: The use of SLRs in education; Experiences of novices using SLRs; The adoption of mapping and scoping studies; The repeatability of SLRs; Improving the search and selection processes; Quality assessment of primary studies; Improving aggregation processes.It therefore seems appropriate to identify the current status of such studies in software engineering, and identify whether there is evidence for revising and/or extending the guidelines for performing systematic literature reviews (Kitchenham and Charters, 2007). This keynote will report the current results of an ongoing systematic literature review that aims: A1: To identify and categorise papers investigating the SLR process and the claims relating to that process; A2: To identify the extent to which the claims of repeatability, lack of bias, and openness are supported; A3: To identify any areas where current guidelines need to be amended or extended to reflect current knowledge of applying SLRs in the context of software engineering.},
  isbn = {978-1-4503-1509-8},
  file = {C:\Users\Karl\Zotero\storage\BRYUK9GX\Kitchenham - 2012 - Systematic review in software engineering where we are and where we should be going.pdf}
}

@article{kleinwaksOntologyTechnicalDebt2023,
  title = {Ontology for {{Technical Debt}} in {{Systems Engineering}}},
  author = {Kleinwaks, Howard and Batchelor, Ann and Bradley, Thomas H.},
  year = {2023},
  journal = {IEEE Open Journal of Systems Engineering},
  volume = {1},
  pages = {111--122},
  issn = {2771-9987},
  doi = {10.1109/OJSE.2023.3316395},
  urldate = {2025-02-17},
  abstract = {The technical debt metaphor is used to describe the long-term consequences of engineering decisions made to achieve a short-term benefit. The metaphor originated in the field of software engineering and has begun to migrate to other fields, including systems engineering. The usage of the metaphor, its associated terminology, and basic definitions vary both within the software field and within the greater engineering community. The lack of consistent definitions inhibits the ability of system developers to understand and control technical debt within their system developments. This article presents an ontology for technical debt, focusing on the field of systems engineering. By providing a set of concise and consolidated definitions, this ontology enables precise discussion of technical debt and associated techniques for mitigating its impact within systems engineering.},
  keywords = {Ontologies,Ontology,rework,Software engineering,systems engineering,Systems engineering and theory,Taxonomy,technical debt (TD),Terminology},
  file = {C:\Users\Karl\Zotero\storage\8ZTST5TA\10254240.html}
}

@article{kleinwaksTechnicalDebtSystems2023,
  title = {Technical Debt in Systems Engineering---{{A}} Systematic Literature Review.},
  author = {Kleinwaks, Howard and Batchelor, Ann and Bradley, Thomas H.},
  year = {2023},
  month = sep,
  journal = {Systems Engineering},
  volume = {26},
  number = {5},
  pages = {675--687},
  publisher = {Wiley-Blackwell},
  issn = {1098-1241},
  doi = {10.1002/sys.21681},
  urldate = {2025-02-17},
  abstract = {The metaphor of "technical debt" is used in software engineering to describe technical solutions that may be pragmatic in the near-term but may have a negative long-term impact. Similar decisions and similar dynamics are present in the field of systems engineering. This work investigates the current body of knowledge to identify if, and how, the technical debt metaphor is used within the systems engineering field and which systems engineering lifecycle stages are most susceptible to technical debt. A systematic literature review was conducted on 354 papers in February 2022, of which 18 were deemed relevant for inclusion in the study. The results of the systematic literature review show that the technical debt metaphor is not prevalent within systems engineering research and that existing research is limited to specific fields and theoretical discussions. This paper concludes with recommendations for future work to establish a research agenda on the identification and management of technical debt within systems engineering.},
  langid = {english},
  keywords = {DEBT management,PRAGMATICS,SOFTWARE engineering,SYSTEMS engineering},
  file = {C:\Users\Karl\Zotero\storage\6CLWFUL6\Kleinwaks et al. - 2023 - Technical debt in systems engineering—A systematic literature review..pdf}
}

@article{lehmanProgramsLifeCycles1980,
  title = {Programs, Life Cycles, and Laws of Software Evolution},
  author = {Lehman, M.M.},
  year = {1980},
  month = sep,
  journal = {Proceedings of the IEEE},
  volume = {68},
  number = {9},
  pages = {1060--1076},
  issn = {1558-2256},
  doi = {10.1109/PROC.1980.11805},
  urldate = {2025-02-07},
  abstract = {By classifying programs according to their relationship to the environment in which they are executed, the paper identifies the sources of evolutionary pressure on computer applications and programs and shows why this results in a process of never ending maintenance activity. The resultant life cycle processes are then briefly discussed. The paper then introduces laws of Program Evolution that have been formulated following quantitative studies of the evolution of a number of different systems. Finally an example is provided of the application of Evolution Dynamics models to program release planning.},
  keywords = {Application software,Automatic programming,Computer applications,Economic indicators,Environmental economics,Fabrics,Microprocessors,Productivity,Software maintenance},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\QSQU4BVX\\lehman.pdf;C\:\\Users\\Karl\\Zotero\\storage\\MQJHBMP2\\1456074.html}
}

@article{lehmanSoftwareEvolutionBackground2003,
  title = {Software Evolution---{{Background}}, Theory, Practice},
  author = {Lehman, Meir M. and Ramil, Juan F.},
  year = {2003},
  month = oct,
  journal = {Information Processing Letters},
  series = {To Honour {{Professor W}}.{{M}}. {{Turski}}'s {{Contribution}} to {{Computing Science}} on the {{Occasion}} of His 65th {{Birthday}}},
  volume = {88},
  number = {1},
  pages = {33--44},
  issn = {0020-0190},
  doi = {10.1016/S0020-0190(03)00382-X},
  urldate = {2025-03-03},
  abstract = {This paper opens with a brief summary of some 30 years of study of the software evolution phenomenon. The results of those studies include the SPE program classification, a principle of software uncertainty and laws of E-type software evolution. The laws were termed so because they encapsulate phenomena largely independent of the people, the organisations and the domains involved in the evolution of the E-type systems studied. Recent studies have refined earlier conclusions, yielded practical guidelines for software evolution management and provide a basis for the formation of a theory of software evolution. Given the volume of published material and the extent of recent discussions on the topic (see, e.g., [Proc. ICSM, Montreal, 2002, p.~66]), this paper is restricted to an overview that exposes the significance of the evolution phenomenon and its study to the wider community, providing a basis for the future and, in particular, development of a theory of software evolution.},
  keywords = {Assumptions,Best practice,Laws of software evolution,Maintenance,Safety/security in digital systems,Software design and implementation,Software engineering,Software evolution,Software process,Software uncertainty principle,Theory of software evolution},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\J6NDYHTM\\Lehman und Ramil - 2003 - Software evolution—Background, theory, practice.pdf;C\:\\Users\\Karl\\Zotero\\storage\\WG5EDLXI\\S002001900300382X.html}
}

@article{maxwellSoftwareDevelopmentProductivity1996,
  title = {Software Development Productivity of {{European}} Space, Military, and Industrial Applications},
  author = {Maxwell, K.D. and Van Wassenhove, L. and Dutta, S.},
  year = {1996},
  month = oct,
  journal = {IEEE Transactions on Software Engineering},
  volume = {22},
  number = {10},
  pages = {706--718},
  issn = {00985589},
  doi = {10.1109/32.544349},
  urldate = {2025-02-07},
  copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\QCJUPMHH\Maxwell et al. - 1996 - Software development productivity of European space, military, and industrial applications.pdf}
}

@inproceedings{murphySoftwareEngineeringResearch2021,
  title = {Is Software Engineering Research Addressing Software Engineering Problems? (Keynote)},
  shorttitle = {Is Software Engineering Research Addressing Software Engineering Problems?},
  booktitle = {Proceedings of the 35th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}}},
  author = {Murphy, Gail C.},
  year = {2021},
  month = jan,
  series = {{{ASE}} '20},
  pages = {4--5},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3324884.3417103},
  urldate = {2025-02-19},
  abstract = {Brian Randell described software engineering as "the multi-person development of multi-version programs". David Parnas expressed that this "pithy phrase implies everything that differentiates software engineering from other programming" (Parnas, 2011). How does current software engineering research compare against this definition? Is there too much focus currently on research into problems and techniques more associated with programming than software engineering? Are there opportunities to use Randell's description of software engineering to guide the community to new research directions? In this extended abstract, I motivate the keynote, which explores these questions and discusses how a consideration of the development streams used by multiple individuals to produce multiple versions of software opens up new avenues for impactful software engineering research.},
  isbn = {978-1-4503-6768-4},
  file = {C:\Users\Karl\Zotero\storage\QX3KG7S7\Murphy - 2021 - Is software engineering research addressing software engineering problems (keynote).pdf}
}

@article{oakleyDEFENSESOFTWAREACQUISITIONS2023,
  title = {{{DEFENSE SOFTWARE ACQUISITIONS}}: {{Changes}} to {{Requirements}}, {{Oversight}}, and {{Tools Needed}} for {{Weapon Programs}}.},
  shorttitle = {{{DEFENSE SOFTWARE ACQUISITIONS}}},
  author = {Oakley, Shelby S.},
  year = {2023},
  month = jul,
  journal = {GAO Reports},
  pages = {1--37},
  publisher = {United States Government Accountability Office},
  urldate = {2025-02-03},
  abstract = {The article focuses on the Government Accountability Office's (GAO) assessment of the Department of Defense's (DOD) software modernization efforts. The three topics covered are the establishment of policy and guidance for Agile software development in weapon programs, providing direction for overseeing Agile software development, and enabling program adoption of modern engineering tools for Agile.},
  langid = {english},
  keywords = {AGILE software development,ENGINEERING equipment,MILITARY weapons,Other Professional Equipment and Supplies Merchant Wholesalers,UNITED States. Dept. of Defense,UNITED States. Government Accountability Office},
  file = {C:\Users\Karl\Zotero\storage\R7WZ45X8\Oakley - 2023 - DEFENSE SOFTWARE ACQUISITIONS Changes to Requirements, Oversight, and Tools Needed for Weapon Progr.pdf}
}

@misc{OntologyTechnicalDebt,
  title = {Ontology for {{Technical Debt}} in {{Systems Engineering}} {\textbar} {{IEEE Journals}} \& {{Magazine}} {\textbar} {{IEEE Xplore}}},
  urldate = {2025-02-17},
  howpublished = {https://ieeexplore.ieee.org/document/10254240},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\SD8SZ5JV\\Kleinwaks et al. - 2023 - Ontology for Technical Debt in Systems Engineering.pdf;C\:\\Users\\Karl\\Zotero\\storage\\VDP97N42\\10254240.html}
}

@article{PDFNoSilver2024,
  title = {({{PDF}}) {{No Silver Bullet Essence}} and {{Accidents}} of {{Software Engineering}}},
  year = {2024},
  month = oct,
  journal = {ResearchGate},
  doi = {10.1109/MC.1987.1663532},
  urldate = {2025-02-19},
  abstract = {PDF {\textbar} First Page of the Article {\textbar} Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\YSWPFCDC\220477127_No_Silver_Bullet_Essence_and_Accidents_of_Software_Engineering.html}
}

@article{PDFNoSilver2024a,
  title = {({{PDF}}) {{No Silver Bullet Essence}} and {{Accidents}} of {{Software Engineering}}},
  year = {2024},
  month = oct,
  journal = {ResearchGate},
  doi = {10.1109/MC.1987.1663532},
  urldate = {2025-02-19},
  abstract = {PDF {\textbar} First Page of the Article {\textbar} Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\WW7DYUC4\220477127_No_Silver_Bullet_Essence_and_Accidents_of_Software_Engineering.html}
}

@article{PDFSystematicLiterature2025,
  title = {({{PDF}}) {{A}} Systematic Literature Review of Literature Reviews in Software Testing},
  year = {2025},
  month = feb,
  journal = {ResearchGate},
  doi = {10.1016/j.infsof.2016.09.002},
  urldate = {2025-02-19},
  abstract = {PDF {\textbar} Context: Any newcomer or industrial practitioner is likely to experience difficulties in digesting large volumes of knowledge in software testing.... {\textbar} Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\7LDEIU8J\\2025 - (PDF) A systematic literature review of literature reviews in software testing.pdf;C\:\\Users\\Karl\\Zotero\\storage\\RJGIBXMQ\\308092761_A_systematic_literature_review_of_literature_reviews_in_software_testing.html}
}

@book{RefactoringImprovingDesign1999,
  title = {Refactoring: Improving the Design of Existing Code},
  shorttitle = {Refactoring},
  year = {1999},
  month = jun,
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {USA},
  abstract = {As the application of object technology--particularly the Java programming language--has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, "non-optimal" applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as "refactoring," these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Code, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process.With proper training a skilled system designer can take a bad design and rework it into well-designed, robust code. In this book, Martin Fowler shows you where opportunities for refactoring typically can be found, and how to go about reworking a bad design into a good one. Each refactoring step is simple--seemingly too simple to be worth doing. Refactoring may involve moving a field from one class to another, or pulling some code out of a method to turn it into its own method, or even pushing some code up or down a hierarchy. While these individual steps may seem elementary, the cumulative effect of such small changes can radically improve the design. Refactoring is a proven way to prevent software decay.In addition to discussing the various techniques of refactoring, the author provides a detailed catalog of more than seventy proven refactorings with helpful pointers that teach you when to apply them; step-by-step instructions for applying each refactoring; and an example illustrating how the refactoring works. The illustrative examples are written in Java, but the ideas are applicable to any object-oriented programming language. 0201485672B04062001},
  isbn = {978-0-201-48567-7},
  file = {C:\Users\Karl\Zotero\storage\P7FVIZ3U\Fowler et al. - Refactoring - Improving the Design of Existing Code.pdf}
}

@article{reimanisStudyBehavioralDecay2024,
  title = {A Study of Behavioral Decay in Design Patterns.},
  author = {Reimanis, Derek and Izurieta, Clemente},
  year = {2024},
  month = jul,
  journal = {Journal of Software: Evolution \& Process},
  volume = {36},
  number = {7},
  pages = {1--20},
  publisher = {Wiley-Blackwell},
  issn = {2047-7473},
  doi = {10.1002/smr.2638},
  urldate = {2025-02-03},
  abstract = {Design patterns represent a means of communicating reusable solutions to common problems, provided they are implemented and maintained correctly. However, many design pattern instances erode as they age, sacrificing qualities they once provided. Identifying such instances of pattern decay is valuable because it allows for proactive attempts to extend the longevity and quality attributes of pattern components. Apart from structural decay, design patterns can exhibit symptoms of behavioral decay. We utilized a taxonomy that characterizes these negative behaviors and designed a case study wherein we measured structural and behavioral decay, hereafter referred to as pattern grime, as well as pattern quality and size, across pattern evolutions. We evaluated the relationships between structural and behavioral grime and found statistically significant cases of strong correlations between specific types of structural and behavioral grime. Furthermore, we extended the QATCH operational software quality model to incorporate design pattern evolution metrics and measured and correlated software quality to the presence of behavioral grime in software systems. Our results suggest a strong inverse relationship between software quality and behavioral grime.},
  langid = {english},
  keywords = {COMPUTER software quality control,SOFTWARE architecture,SOFTWARE engineering,SOFTWARE maintenance,SOFTWARE measurement,SYSTEMS software},
  file = {C:\Users\Karl\Zotero\storage\FVY965RL\Reimanis und Izurieta - 2024 - A study of behavioral decay in design patterns..pdf}
}

@article{rinta-kahilaGETTINGTRAPPEDTECHNICAL2023,
  title = {{{GETTING TRAPPED IN TECHNICAL DEBT}}: {{SOCIOTEGETTING TRAPPED IN TECHNICAL DEBT}}: {{SOCIOTECHNICAL ANALYSIS OF A LEGACY SYSTEM}}'{{S REPLACEMENT1CHNICAL ANALYSIS OF A LEGACY SYSTEM}}'{{S REPLACEMENT}}.},
  shorttitle = {{{GETTING TRAPPED IN TECHNICAL DEBT}}},
  author = {{Rinta-Kahila}, Tapani and Penttinen, Esko and Lyytinen, Kalle},
  year = {2023},
  month = mar,
  journal = {MIS Quarterly},
  volume = {47},
  number = {1},
  pages = {1--31},
  publisher = {MIS Quarterly},
  issn = {0276-7783},
  doi = {10.25300/MISQ/2022/16711},
  urldate = {2025-02-17},
  abstract = {Organizations replace their legacy systems for technical, economic, and operational reasons. Replacement is a risky proposition, as high levels of technical and social inertia make these systems hard to withdraw. Failure to fully replace systems results in complex system architectures involving manifold hidden dependencies that carry technical debt. To understand how a process for replacing a complex legacy system unfolds and accumulates technical debt, we conducted an explanatory case study at a local manufacturing site that had struggled to replace its mission-critical legacy systems as part of the larger global company's commercial-off-the-shelf (COTS) system implementation. We approach the replacement as a sociotechnical change and leverage the punctuated sociotechnical information system change model in combination with the design-moves framework to analyze how the site balanced creating digital options, countering social inertia, and managing (architectural) technical debt. The findings generalize to a two-level (local/global) system-dynamics model delineating how replacing a deeply entrenched mission-critical system generates positive and negative feedback loops within and between social and technical changes at local and global levels. The loops, unless addressed, accrue technical debt that hinders legacy system discontinuance and gradually locks the organization into a debtconstrained state. The model helps managers anticipate challenges that accompany replacing highly entrenched systems and formulate effective strategies to address them.},
  langid = {english},
  keywords = {Consumer Lending,CORPORATE debt,CORPORATE finance,DIFFUSION of innovations,INDUSTRIAL management,INNOVATION adoption,ORGANIZATIONAL change,TECHNOLOGY},
  file = {C:\Users\Karl\Zotero\storage\WZVBLUV7\Rinta-Kahila et al. - 2023 - GETTING TRAPPED IN TECHNICAL DEBT SOCIOTEGETTING TRAPPED IN TECHNICAL DEBT SOCIOTECHNICAL ANALYSIS.pdf}
}

@article{riquetDebtStoriesCapturing2024,
  title = {Debt {{Stories}}: {{Capturing Social}} and {{Technical Debt}} in the {{Industry}}},
  shorttitle = {Debt {{Stories}}},
  author = {Riquet, Nicolas and Devroey, Xavier and Vanderose, Benoit},
  year = {2024},
  month = apr,
  journal = {2024 IEEE/ACM International Conference on Technical Debt (TechDebt), Technical Debt (TechDebt), 2024 IEEE/ACM International Conference on, TECHDEBT},
  pages = {40--44},
  publisher = {ACM},
  issn = {979-8-4007-0590-8},
  urldate = {2025-02-17},
  abstract = {In today's organizations, software is mission-critical. However, the legacy of past decisions can make tasks related to artifacts increasingly inefficient or risky, creating debt. While most researchers and practitioners mainly focus on technical debt, some have investigated its social dimensions, known as social debt. We argue that organizations developing software need to tackle debt holistically, as it is intrinsically a socio-technical issue. In this short paper, we rely on a definition of socio-technical debt based on the existing literature to define Debt Stories: a tool based on the User Story format, that can help capture debt elements directly from the stake-holders involved in software development. A debt story includes information about the role of the stakeholder in the development process, the social or technical context, and the impact of the debt element on the different tasks performed by the stakeholder. We provide a first empirical evaluation of the usage of Debt Stories in an industrial context, demonstrating the relevance of Debt Stories to express and communicate socio-technical debt.CCS CONCEPTS{$\bullet$} Software and its engineering {$\rightarrow$} Agile software development, Software maintenance tools, {$\bullet$} Social and professional topics {$\rightarrow$}Software maintenance},
  keywords = {Computing and Processing,debt stories,DevOps,empirical software engineering,Industries,Maintenance,Mission critical systems,Organizations,Production,socio-technical debt,Software maintenance}
}

@article{una-mayoreillyanderikhemberg.OvercomingCodeRot2018,
  title = {Overcoming Code Rot in Legacy Software Projects},
  author = {{Una-May O'reilly and Erik Hemberg.} and {Massachusetts Institute of Technology. Department of Electrical Engineering and Computer Science.} and Liew, Austin Jun-Yian},
  year = {2018},
  month = jan,
  abstract = {Thesis: M. Eng., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2017.},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\7XDB39QP\Una-May O'reilly and Erik Hemberg. et al. - 2018 - Overcoming code rot in legacy software projects.pdf}
}

@article{vangurpDesignErosionProblems2002,
  title = {Design Erosion: Problems and Causes},
  shorttitle = {Design Erosion},
  author = {{van Gurp}, Jilles and Bosch, Jan},
  year = {2002},
  month = mar,
  journal = {Journal of Systems and Software},
  volume = {61},
  number = {2},
  pages = {105--119},
  issn = {0164-1212},
  doi = {10.1016/S0164-1212(01)00152-2},
  urldate = {2025-02-07},
  abstract = {Design erosion is a common problem in software engineering. We have found that invariably, no matter how ambitious the intentions of the designers were, software designs tend to erode over time to the point that redesigning from scratch becomes a viable alternative compared to prolonging the life of the existing design. In this paper, we illustrate how design erosion works by presenting the evolution of the design of a small software system. In our analysis of this example, we show how design decisions accumulate and become invalid because of new requirements. Also it is argued that even an optimal strategy for designing the system (i.e. no compromises with respect to e.g. cost are made) does not lead to an optimal design because of unforeseen requirement changes that invalidate design decisions that were once optimal.},
  file = {C:\Users\Karl\Zotero\storage\ZVLMARKG\S0164121201001522.html}
}

@misc{VModellXT,
  title = {{V-Modell XT}},
  journal = {Der Beauftragte der Bundesregierung f{\"u}r Informationstechnik},
  urldate = {2025-02-11},
  abstract = {F{\"u}r komplexe und innovative Softwareentwicklung braucht es einen Standard, der strukturiertes Vorgehen mit flexiblen Vorgehensbausteinen kombiniert. Das V-Modell {\textregistered} XT bietet genau das in Form einer anpassbaren Struktur sowie vorgegebener Rollen, Produkte (Ergebnisse) und Abl{\"a}ufe, die die Orientierung im Projekt erleichtern.},
  howpublished = {https://www.cio.bund.de/Webs/CIO/DE/digitaler-wandel/Achitekturen\_und\_Standards/V\_modell\_xt/v\_modell\_xt-artikel.html?nn=18713562},
  langid = {ngerman},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\63I5MFYW\\V-Modell XT.pdf;C\:\\Users\\Karl\\Zotero\\storage\\JWZ7IBGS\\v_modell_xt-node.html}
}
