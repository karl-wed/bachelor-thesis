@inproceedings{296790,
  title = {Software Aging},
  shorttitle = {Software {{Aging}}},
  booktitle = {Proceedings of 16th International Conference on Software Engineering},
  author = {Parnas, David Lorge},
  date = {1994},
  pages = {279--287},
  doi = {10.1109/ICSE.1994.296790},
  keywords = {Aging,Command languages,Embedded software,Engineering profession,Humans,Impedance,Machinery,Mathematics,Product design,Programming profession},
  file = {C:\Users\Karl\Zotero\storage\IFYMKUZC\Parnas - 1994 - Software aging.pdf}
}

@inproceedings{8170137,
  title = {Identifying Software Decays: A System Usage Perspective},
  booktitle = {2017 {{ACM}}/{{IEEE}} International Symposium on Empirical Software Engineering and Measurement ({{ESEM}})},
  author = {Mubin, Ashirul and Kuai, Meng},
  date = {2017-11},
  pages = {472--473},
  publisher = {IEEE Computer Society},
  location = {Los Alamitos, CA, USA},
  doi = {10.1109/ESEM.2017.64},
  url = {https://doi.ieeecomputersociety.org/10.1109/ESEM.2017.64},
  abstract = {The value of a software product diminishes due to emerging new requirements and gradual changes in system usage patterns over its lifespan, including other direct or indirect impacts from the surrounding environment. Often new requirements or changes cannot be addressed instantly; therefore, the system becomes less effective with incompatible or unused features, gradually degrading the overall value of its services. We term this as software decay. In this paper, we attempt to discover this decay during earlier stages in the usage cycle; and measure it by quantifying its system value based on the access rates of its prime features that are necessary to perform its due services for the intended users.},
  keywords = {Computer science,Correlation,Indexes,Object recognition,Software,Software engineering,Software measurement},
  file = {C:\Users\Karl\Zotero\storage\4B7L9HHN\Mubin und Kuai - 2017 - Identifying software decays a system usage perspective.pdf}
}

@article{alharbiEmpiricalInvestigationRelationship2024,
  title = {An Empirical Investigation of the Relationship between Pattern Grime and Code Smells},
  author = {Alharbi, Maha and Alshayeb, Mohammad},
  date = {2024-09-01},
  journaltitle = {Journal of Software: Evolution and Process},
  volume = {36},
  number = {9},
  pages = {e2666},
  publisher = {John Wiley \& Sons, Ltd},
  issn = {2047-7481},
  doi = {10.1002/smr.2666},
  url = {https://onlinelibrary.wiley.com/doi/10.1002/smr.2666},
  urldate = {2025-02-03},
  abstract = {The results indicate that, in general, the growth of grime is more likely to co-occur with code smells. Specifically, there is a strong positive association between the growth of pattern grime at the...},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\NM6BC5BZ\Alharbi und Alshayeb - 2024 - An empirical investigation of the relationship between pattern grime and code smells.pdf}
}

@inproceedings{almadiInvestigatingViolationsRoles2022,
  title = {Toward investigating the violations roles of pattern grime occurrence in software design patterns violations roles of pattern grime},
  author = {Almadi, Sara H.S.},
  date = {2022-01-01},
  publisher = {Association for Computing Machinery},
  location = {Malaysia, Australia},
  url = {https://research.ebsco.com/linkprocessor/plink?id=e4aa6f52-1569-3886-82c8-aaded3f92d36},
  abstract = {Design patterns (DPs) are recurring solutions for software design problems. They are recommended and employed for their benefits and impact on software quality. However, the improper extension and implementation of design patterns raise the emergence of accumulating bad smells in DPs structure and behavior. Pattern grime occurrence is one of the bad smells in the design pattern. Grime highly reduces design pattern usability, testability, and adaptability, and even prevents their proper implementation. Despite that, pattern grime occurrence may have many severe violations and impacts on design patterns. For instance, grime occurrence contributes to build-up code smells, violates object-oriented principles, and degenerates pattern quality and code structure. This research focuses on investigating the violations roles of grime occurrence in design patterns and aims to propose a taxonomy for pattern grime violation types, to take the first step to develop a prediction model to detect pattern grime occurrence in the software design pattern. Thus, this research outlines a research project targeting the main research question: "how pattern grime is correlated, and how this might lead to violate design pattern principles, structure, and quality? We plan to answer this question through various stages. First, we investigate the commonalities and variability of pattern grime occurrence on design patterns. Secondly, we identify the types of grime roles violation in DPs to propose a taxonomy of pattern grime violation types. The results of these stages will help to identify a prediction model to predict pattern grime in the software design patterns. Â© 2022 ACM.},
  langid = {unknown},
  keywords = {QA76 Computer software}
}

@article{almadiInvestigatingViolationsRoles2022a,
  title = {Toward Investigating the Violations Roles of Pattern Grime Occurrence in Software Design Patterns},
  author = {Almadi, Sara H. S.},
  date = {2022-06-13},
  journaltitle = {The International Conference on Evaluation and Assessment in Software Engineering 2022},
  publisher = {ACM},
  doi = {10.1145/3530019.3535347},
  url = {https://research.ebsco.com/linkprocessor/plink?id=4ce54f9c-2aa3-3006-ada8-76b9710cb363},
  urldate = {2025-02-03},
  langid = {Undetermined},
  file = {C:\Users\Karl\Zotero\storage\EYTI6U4H\Almadi - 2022 - Toward Investigating the Violations Roles of Pattern Grime Occurrence in Software Design Patterns.pdf}
}

@inproceedings{avgeriouTechnicalDebtManagement2023,
  title = {Technical {{Debt Management}}: {{The Road Ahead}} for {{Successful Software Delivery}}},
  shorttitle = {Technical {{Debt Management}}},
  booktitle = {2023 {{IEEE}}/{{ACM International Conference}} on {{Software Engineering}}: {{Future}} of {{Software Engineering}} ({{ICSE-FoSE}})},
  author = {Avgeriou, Paris and Ozkaya, Ipek and Chatzigeorgiou, Alexander and Ciolkowski, Marcus and Ernst, Neil A. and Koontz, Ronald J. and Poort, Eltjo and Shull, Forrest},
  date = {2023-05-14},
  eprint = {2403.06484},
  eprinttype = {arXiv},
  eprintclass = {cs},
  pages = {15--30},
  doi = {10.1109/ICSE-FoSE59343.2023.00007},
  url = {http://arxiv.org/abs/2403.06484},
  urldate = {2025-03-17},
  abstract = {Technical Debt, considered by many to be the 'silent killer' of software projects, has undeniably become part of the everyday vocabulary of software engineers. We know it compromises the internal quality of a system, either deliberately or inadvertently. We understand Technical Debt is not all derogatory, often serving the purpose of expediency. But, it is associated with a clear risk, especially for large and complex systems with extended service life: if we do not properly manage Technical Debt, it threatens to "bankrupt" those systems. Software engineers and organizations that develop software-intensive systems are facing an increasingly more dire future state of those systems if they do not start incorporating Technical Debt management into their day to day practice. But how? What have the wins and losses of the past decade of research and practice in managing Technical Debt taught us and where should we focus next? In this paper, we examine the state of the art in both industry and research communities in managing Technical Debt; we subsequently distill the gaps in industrial practice and the research shortcomings, and synthesize them to define and articulate a vision for what Technical Debt management looks like five years hence.},
  keywords = {Computer Science - Software Engineering},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\WRFYSQ5L\\Avgeriou et al. - 2023 - Technical Debt Management The Road Ahead for Successful Software Delivery.pdf;C\:\\Users\\Karl\\Zotero\\storage\\5EDM4VH5\\2403.html}
}

@article{bankerSoftwareComplexityMaintenance1993,
  title = {Software Complexity and Maintenance Costs},
  shorttitle = {Software {{Complexity}}},
  author = {Banker, Rajiv and Datar, Srikant and Kemerer, Chris and Zweig, Dani},
  date = {1993-11-01},
  journaltitle = {Communications of the ACM},
  volume = {36},
  number = {11},
  publisher = {ACMPUB27New York, NY, USA},
  doi = {10.1145/163359.163375},
  url = {https://dl.acm.org/doi/10.1145/163359.163375},
  urldate = {2025-03-10},
  langid = {english},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\8FFXHXB5\\D et al. - 1993 - Software complexity and maintenance costs.pdf;C\:\\Users\\Karl\\Zotero\\storage\\RVVXW8H5\\163359.html}
}

@inproceedings{bauerFrameworkIncrementalQuality2012,
  title = {A Framework for Incremental Quality Analysis of Large Software Systems},
  booktitle = {2012 28th {{IEEE International Conference}} on {{Software Maintenance}} ({{ICSM}})},
  author = {Bauer, Veronika and Heinemann, Lars and Hummel, Benjamin and Juergens, Elmar and Conradt, Michael},
  date = {2012-09},
  pages = {537--546},
  issn = {1063-6773},
  doi = {10.1109/ICSM.2012.6405318},
  url = {https://ieeexplore.ieee.org/document/6405318},
  urldate = {2025-03-21},
  abstract = {To provide rapid feedback to engineers, software quality analysis must be incremental. However, most existing analyses are either not incremental, or limited to isolated quality characteristics. In practice, this prevents their integration into a uniform quality control approach. In this paper, we present a framework for the incremental and distributed computation of quality characteristics. It is fast enough for real-time analysis of large systems and provides a complete history of analysis results. An evaluation on several open source software systems demonstrates its scalability to large code bases under active development.},
  eventtitle = {2012 28th {{IEEE International Conference}} on {{Software Maintenance}} ({{ICSM}})},
  keywords = {Cloning,Conferences,History,Indexes,Measurement,Quality control,Software},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\32EC9LE9\\Bauer et al. - 2012 - A framework for incremental quality analysis of large software systems.pdf;C\:\\Users\\Karl\\Zotero\\storage\\9KQM38X2\\6405318.html}
}

@book{beckExtremeProgrammingExplained1999,
  title = {Extreme {{Programming Explained}}: {{Embrace Change}}},
  shorttitle = {Extreme {{Programming Explained}}},
  author = {Beck, Kent},
  date = {1999},
  eprint = {G8EL4H4vf7UC},
  eprinttype = {googlebooks},
  publisher = {Addison-Wesley Professional},
  abstract = {Software development projects can be fun, productive, and even daring. Yet they can consistently deliver value to a business and remain under control.  Extreme Programming (XP) was conceived and developed to address the specific needs of software development conducted by small teams in the face of vague and changing requirements. This new lightweight methodology challenges many conventional tenets, including the long-held assumption that the cost of changing a piece of software necessarily rises dramatically over the course of time. XP recognizes that projects have to work to achieve this reduction in cost and exploit the savings once they have been earned.  Fundamentals of XP include:   Distinguishing between the decisions to be made by business interests and those to be made by project stakeholders.  Writing unit tests before programming and keeping all of the tests running at all times.  Integrating and testing the whole system--several times a day.  Producing all software in pairs, two programmers at one screen.  Starting projects with a simple design that constantly evolves to add needed flexibility and remove unneeded complexity.  Putting a minimal system into production quickly and growing it in whatever directions prove most valuable.   Why is XP so controversial? Some sacred cows don't make the cut in XP:   Don't force team members to specialize and become analysts, architects, programmers, testers, and integrators--every XP programmer participates in all of these critical activities every day.  Don't conduct complete up-front analysis and design--an XP project starts with a quick analysis of the entire system, and XPprogrammers continue to make analysis and design decisions throughout development.  Develop infrastructure and frameworks as you develop your application, not up-front--delivering business value is the heartbeat that drives XP projects.  Don't write and maintain implementation documentation--communication in XP projects occurs face-to-face, or through efficient tests and carefully written code.   You may love XP, or you may hate it, but "Extreme Programming Explained" will force you to take a fresh look at how you develop software.  0201616416B04062001},
  isbn = {978-0-201-61641-5},
  langid = {english},
  pagetotal = {228},
  keywords = {Computers / Languages / General,Computers / Programming / General,Computers / Software Development & Engineering / General}
}

@book{beckTestdrivenDevelopmentExample2002,
  title = {Test-Driven Development : By Example},
  shorttitle = {Test-Driven Development},
  author = {Beck, Kent},
  date = {2002-11-08},
  publisher = {Boston : Addison-Wesley},
  url = {http://archive.org/details/est-driven-development-by-example},
  urldate = {2025-03-24},
  abstract = {Clean code that works--now. This is the seeming contradiction  that lies behind much of the pain of programming. Test-driven  development replies to this contradiction with a paradox--test the  program before you write it.  A new idea? Not at all. Since the  dawn of computing, programmers have been specifying the inputs and  outputs before programming precisely. Test-driven development takes this  age-old idea, mixes it with modern languages and programming  environments, and cooks up a tasty stew guaranteed to satisfy your  appetite for clean code that works--now.  Developers face complex  programming challenges every day, yet they are not always readily  prepared to determine the best solution. More often than not, such  difficult projects generate a great deal of stress and bad code. To  garner the strength and courage needed to surmount seemingly Herculean  tasks, programmers should look to test-driven development (TDD), a  proven set of techniques that encourage simple designs and test suites  that inspire confidence.   By driving development with automated  tests and then eliminating duplication, any developer can write  reliable, bug-free code no matter what its level of complexity.  Moreover, TDD encourages programmers to learn quickly, communicate more  clearly, and seek out constructive feedback.   Readers will learn to:  Solve complicated tasks, beginning with the simple and proceeding to the more complex.  Write automated tests before coding.   Grow a design organically by refactoring to add design decisions one at a time.  Create tests for more complicated logic, including reflection and exceptions.  Use patterns to decide what tests to write.  Create tests using xUnit, the architecture at the heart of many programmer-oriented testing tools. This  book follows two TDD projects from start to finish, illustrating  techniques programmers can use to easily and dramatically increase the  quality of their work. The examples are followed by references to the  featured TDD patterns and refactorings. With its emphasis on agile  methods and fast development strategies, Test-Driven Development is sure to inspire readers to embrace these under-utilized but powerful techniques. ; xix, 220 pages : 24 cm; "This book follows two TDD projects from start to finish, illustrating techniques programmers can use to easily and dramatically increase the quality of their work. The examples are followed by references to the featured TDD patterns and refactorings. With its emphasis on agile methods and fast development strategies, Test-Driven Development is sure to inspire readers to embrace these under-utilized but powerful techniques."--Jacket; Includes bibliographical references and index},
  isbn = {978-0-321-14653-3},
  langid = {english},
  keywords = {TDD}
}

@article{beladyModelLargeProgram1976,
  title = {A {{Model}} of {{Large Program Development}}},
  shorttitle = {Large {{Program Development}}},
  author = {Belady, L. and Lehman, M.},
  date = {1976},
  journaltitle = {IBM Systems Journal},
  url = {https://www.semanticscholar.org/paper/A-Model-of-Large-Program-Development-Belady-Lehman/09925fa25fa1cf78a63132ab57cbb33d067042ba},
  urldate = {2025-03-05},
  abstract = {Observations made on the development of OS/360 and its subsequent enhancements and releases are discussed and some modeling approaches to organizing these observations are presented. Discussed are observations made on the development of OS/360 and its subsequent enhancements and releases. Some modeling approaches to organizing these observations are also presented.},
  langid = {english},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\NAGU7S6E\\Belady und Lehman - 1976 - A Model of Large Program Development.pdf;C\:\\Users\\Karl\\Zotero\\storage\\QTVG6TZP\\09925fa25fa1cf78a63132ab57cbb33d067042ba.html}
}

@article{beskerManagingArchitecturalTechnical2018,
  title = {Managing Architectural Technical Debt: {{A}} Unified Model and Systematic Literature Review},
  shorttitle = {Managing Architectural Technical Debt},
  author = {Besker, Terese and Martini, Antonio and Bosch, Jan},
  date = {2018-01-01},
  journaltitle = {Journal of Systems and Software},
  shortjournal = {Journal of Systems and Software},
  volume = {135},
  pages = {1--16},
  issn = {0164-1212},
  doi = {10.1016/j.jss.2017.09.025},
  url = {https://www.sciencedirect.com/science/article/pii/S0164121217302121},
  urldate = {2025-03-24},
  abstract = {Large Software Companies need to support the continuous and fast delivery of customer value in both the short and long term. However, this can be impeded if the evolution and maintenance of existing systems is hampered by what has been recently termed Technical Debt (TD). Specifically, Architectural TD has received increased attention in the last few years due to its significant impact on system success and, left unchecked, it can cause expensive repercussions. It is therefore important to understand the underlying factors of architectural TD. With this as background, there is a need for a descriptive model to illustrate and explain different architectural TD issues. The aim of this study is to synthesize and compile research efforts with the goal of creating new knowledge with a specific interest in the architectural TD field. The contribution of this paper is the presentation of a novel descriptive model, providing a comprehensive interpretation of the architectural TD phenomenon. This model categorizes the main characteristics of architectural TD and reveals their relations. The results show that, by using this model, different stakeholders could increase the system's success rate, and lower the rate of negative consequences, by raising awareness about architectural TD.},
  keywords = {Architectural technical debt,Software architecture,Software maintenance,Systematic literature review},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\EJ3JQPAM\\Besker et al. - 2018 - Managing architectural technical debt A unified model and systematic literature review.pdf;C\:\\Users\\Karl\\Zotero\\storage\\6TWCUC4V\\S0164121217302121.html}
}

@article{bhadauriaPerformanceOutcomesTestDriven2020,
  title = {Performance {{Outcomes}} of {{Test-Driven Development}}: {{An Experimental Investigation}}},
  shorttitle = {Performance {{Outcomes}} of {{Test-Driven Development}}},
  author = {Bhadauria, Vikram and Mahapatra, Radha and Nerur, Sridhar},
  date = {2020-07-15},
  journaltitle = {Journal of the Association for Information Systems},
  volume = {21},
  number = {4},
  issn = {1536-9323},
  doi = {10.17705/1jais.00628},
  url = {https://aisel.aisnet.org/jais/vol21/iss4/2},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\4PHW4AHJ\\Bhadauria et al. - 2020 - Performance Outcomes of Test-Driven Development An Experimental Investigation.pdf;C\:\\Users\\Karl\\Zotero\\storage\\ERRCCG7L\\2.html}
}

@inproceedings{bhatEvaluatingEfficacyTestdriven2006,
  title = {Evaluating the Efficacy of Test-Driven Development: Industrial Case Studies},
  shorttitle = {Evaluating the Efficacy of Test-Driven Development},
  booktitle = {Proceedings of the 2006 {{ACM}}/{{IEEE}} International Symposium on {{Empirical}} Software Engineering},
  author = {Bhat, Thirumalesh and Nagappan, Nachiappan},
  date = {2006-09-21},
  series = {{{ISESE}} '06},
  pages = {356--363},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/1159733.1159787},
  url = {https://doi.org/10.1145/1159733.1159787},
  urldate = {2025-03-24},
  abstract = {This paper discusses software development using the Test Driven Development (TDD) methodology in two different environments (Windows and MSN divisions) at Microsoft. In both these case studies we measure the various context, product and outcome measures to compare and evaluate the efficacy of TDD. We observed a significant increase in quality of the code (greater than two times) for projects developed using TDD compared to similar projects developed in the same organization in a non-TDD fashion. The projects also took at least 15\% extra upfront time for writing the tests. Additionally, the unit tests have served as auto documentation for the code when libraries/APIs had to be used as well as for code maintenance.},
  isbn = {978-1-59593-218-1}
}

@inproceedings{bhatEvaluatingEfficacyTestdriven2006a,
  title = {Evaluating the Efficacy of Test-Driven Development: Industrial Case Studies},
  shorttitle = {Evaluating the Efficacy of Test-Driven Development},
  booktitle = {Proceedings of the 2006 {{ACM}}/{{IEEE}} International Symposium on {{Empirical}} Software Engineering},
  author = {Bhat, Thirumalesh and Nagappan, Nachiappan},
  date = {2006-09-21},
  series = {{{ISESE}} '06},
  pages = {356--363},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/1159733.1159787},
  url = {https://dl.acm.org/doi/10.1145/1159733.1159787},
  urldate = {2025-03-24},
  abstract = {This paper discusses software development using the Test Driven Development (TDD) methodology in two different environments (Windows and MSN divisions) at Microsoft. In both these case studies we measure the various context, product and outcome measures to compare and evaluate the efficacy of TDD. We observed a significant increase in quality of the code (greater than two times) for projects developed using TDD compared to similar projects developed in the same organization in a non-TDD fashion. The projects also took at least 15\% extra upfront time for writing the tests. Additionally, the unit tests have served as auto documentation for the code when libraries/APIs had to be used as well as for code maintenance.},
  isbn = {978-1-59593-218-1},
  file = {C:\Users\Karl\Zotero\storage\28MG77YY\Bhat and Nagappan - 2006 - Evaluating the efficacy of test-driven development industrial case studies.pdf}
}

@online{BlikiTechnicalDebt,
  title = {Bliki: {{Technical Debt Quadrant}}},
  shorttitle = {Bliki},
  url = {https://martinfowler.com/bliki/TechnicalDebtQuadrant.html},
  urldate = {2025-03-11},
  abstract = {People argue about whether some kinds of bad code count as Technical Debt. I prefer to focus on the interest/principal decision, and recognize debt has different causes.},
  organization = {martinfowler.com},
  file = {C:\Users\Karl\Zotero\storage\AG8RZDZJ\TechnicalDebtQuadrant.html}
}

@article{boehmSoftwareEngineeringEconomics1984,
  title = {Software {{Engineering Economics}}},
  author = {Boehm, Barry W.},
  date = {1984-01},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {SE-10},
  number = {1},
  pages = {4--21},
  issn = {1939-3520},
  doi = {10.1109/TSE.1984.5010193},
  url = {https://ieeexplore.ieee.org/document/5010193},
  urldate = {2025-02-19},
  abstract = {This paper summarizes the current state of the art and recent trends in software engineering economics. It provides an overview of economic analysis techniques and their applicability to software engineering and management. It surveys the field of software cost estimation, including the major estimation techniques available, the state of the art in algorithmic cost models, and the outstanding research issues in software cost estimation.},
  eventtitle = {{{IEEE Transactions}} on {{Software Engineering}}},
  keywords = {Analytical models,Computer programming costs,cost models,Costs,Engineering management,Life estimation,management decision aids,Microeconomics,Power generation economics,Resource management,software cost estimation,software economics,software engineering,Software engineering,software management,Software prototyping,State estimation},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\P8F8CISK\\Boehm - 1984 - Software Engineering Economics.pdf;C\:\\Users\\Karl\\Zotero\\storage\\GAH5JYNL\\5010193.html}
}

@article{borowaLivingTechnicalDebt2021,
  title = {Living {{With Technical Debt}}â{{A Perspective From}} the {{Video Game Industry}}},
  author = {Borowa, Klara and Zalewski, Andrzej and Saczko, Adam},
  date = {2021-11},
  journaltitle = {IEEE Software},
  volume = {38},
  number = {6},
  pages = {65--70},
  issn = {1937-4194},
  doi = {10.1109/MS.2021.3103249},
  url = {https://ieeexplore.ieee.org/document/9508260},
  urldate = {2025-02-17},
  abstract = {Video game development has its own specific nature and problems that differentiate it from general software development. We investigated the influence of these factors in a survey and found a distinct lack of systematic management of technical debt.},
  eventtitle = {{{IEEE Software}}},
  keywords = {Costs,Finance,Games,Licenses,Management},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\5V58WFCR\\Borowa et al. - 2021 - Living With Technical DebtâA Perspective From the Video Game Industry.pdf;C\:\\Users\\Karl\\Zotero\\storage\\C8D9Z8B8\\9508260.html}
}

@article{brooksNoSilverBullet1987,
  title = {No {{Silver Bullet Essence}} and {{Accidents}} of {{Software Engineering}}},
  shorttitle = {No {{Silver Bullet}}},
  author = {Brooks, Frederick},
  date = {1987-04},
  journaltitle = {Computer},
  volume = {20},
  number = {4},
  pages = {10--19},
  issn = {1558-0814},
  doi = {10.1109/MC.1987.1663532},
  url = {https://ieeexplore.ieee.org/document/1663532},
  urldate = {2025-02-19},
  eventtitle = {Computer},
  keywords = {Computer industry,Costs,Diseases,Hardware,Industrial accidents,Project management,Roads,Silver,Software engineering,Technological innovation},
  file = {C:\Users\Karl\Zotero\storage\DHLS935P\Brooks - 1987 - No Silver Bullet Essence and Accidents of Software Engineering.pdf}
}

@inproceedings{budlongCommercialMilitarySoftware1984,
  title = {Commercial and Military Software Documentation: Different Steps to a Common Goal},
  shorttitle = {Commercial and Military Software Documentation},
  booktitle = {Proceedings of the {{July}} 9-12, 1984, National Computer Conference and Exposition},
  author = {Budlong, Faye C.},
  date = {1984-07-09},
  series = {{{AFIPS}} '84},
  pages = {389--394},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/1499310.1499360},
  url = {https://dl.acm.org/doi/10.1145/1499310.1499360},
  urldate = {2025-02-19},
  abstract = {Talking about creativity in software documentation may seem like a paradox, but it exists. Even a functional specification for a new product has an element of creativity: It outlines a product that will require the creative endeavors of several developers over a period of time. Further, user manuals require ingenuity to reduce many complex functions to a series of simple, identifiable steps that the user can understand and follow. Training documents require creativity to develop examples that new users can understand and to reinforce a learning curve that allows the reader to become proficient using a new product. And reference manuals require perseverence to ensure that all functions of the product are defined and explained clearly and concisely.This paper is an overview of the development process for software documentation from concept to initial release. It lists much of the documentation required for each major software development step and compares documentation for commercial projects with that required to meet military project standards.},
  isbn = {978-0-88283-043-8},
  file = {C:\Users\Karl\Zotero\storage\TMDIJH3K\Budlong - 1984 - Commercial and military software documentation different steps to a common goal.pdf}
}

@misc{bundesamtfursicherheitinderinformationstechnikITGrundschutz,
  title = {{{IT-Grundschutz}}},
  shorttitle = {{{IT-Grundschutz}}},
  author = {Bundesamt fÃ¼r Sicherheit in der Informationstechnik},
  url = {https://www.bsi.bund.de/EN/Themen/Unternehmen-und-Organisationen/Standards-und-Zertifizierung/IT-Grundschutz/it-grundschutz_node.html},
  urldate = {2025-03-26}
}

@misc{bundesministeriumderverteidigungCustomerProductManagement,
  title = {Customer {{Product Management}}},
  shorttitle = {{{CPM}}},
  author = {Bundesministerium der Verteidigung},
  url = {https://www.bundeswehr.de/resource/blob/1718386/d21a4f590da15adad3aecd560f3cc5cc/cpm-en-data.pdf},
  urldate = {2025-03-26},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\MB4LCZPW\Customer Product Management.pdf}
}

@misc{bundeswehrVModellXTBw,
  title = {V-Modell XT Bw},
  shorttitle = {V-Modell Bw},
  author = {Bundeswehr},
  url = {https://ftp.tu-clausthal.de/pub/institute/informatik/v-modell-xt/Releases/1.4Bw/V-Modell-XT-Bw-Gesamt.pdf},
  urldate = {2025-03-26},
  langid = {ngerman},
  file = {C:\Users\Karl\Zotero\storage\IT8VD9RG\Bw - Teil 1 Grundlagen des V-Modells.pdf}
}

@inproceedings{caraccioloEvaluatingArchitectureConformance2016,
  title = {Evaluating an {{Architecture Conformance Monitoring Solution}}},
  shorttitle = {Evaluating {{Architecture Monitoring}}},
  booktitle = {2016 7th {{International Workshop}} on {{Empirical Software Engineering}} in {{Practice}} ({{IWESEP}})},
  author = {Caracciolo, Andrea and Lungu, Mircea and Truffer, Oskar and Levitin, Kirill and Nierstrasz, Oscar},
  date = {2016-03},
  pages = {41--44},
  doi = {10.1109/IWESEP.2016.12},
  url = {https://ieeexplore.ieee.org/document/7464551},
  urldate = {2025-03-21},
  abstract = {Architectural rules are often defined but rarely tested. Current tools offer limited functionality and often require significant effort to be configured, automated and integrated within existing platforms. We propose a platform that is aimed at reducing the overall cost of setting up and maintaining an architectural conformance monitoring environment by decoupling the conceptual representation of a user-defined rule from its technical specification prescribed by the underlying analysis tools. The user is no longer expected to encode her constraints according to the syntax of the chosen tool, but can use a simple high-level DSL that is automatically compiled to an executable specification through custom adapters developed to support the interaction with existing off-the-shelf tools. In this paper we analyze three case studies to show how this approach can be successfully adopted to support truly diverse industrial projects. By discussing qualitative aspects of the approach, we investigate limitations and opportunities for improving general quality assessment solutions in general and DSL-based conformance tools in particular.},
  eventtitle = {2016 7th {{International Workshop}} on {{Empirical Software Engineering}} in {{Practice}} ({{IWESEP}})},
  keywords = {architecture conformance checking,Context,DSL,Electronic mail,empirical,evaluation,Maintenance engineering,Monitoring,Organizations,Quality assessment},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\JKFTIHRX\\Caracciolo et al. - 2016 - Evaluating an Architecture Conformance Monitoring Solution.pdf;C\:\\Users\\Karl\\Zotero\\storage\\T4WXZCTI\\7464551.html}
}

@incollection{clasenUmgangMitKomplexitaet2019,
  title = {Der Umgang mit KomplexitÃ¤t bei SAP und Bundeswehr â eine subjektive Betrachtung},
  booktitle = {Verwaltung, eGovernment und Digitalisierung: Grundlagen, Konzepte und AnwendungsfÃ¤lle},
  author = {Clasen, Michael},
  editor = {Schmid, Andreas},
  date = {2019},
  pages = {261--272},
  publisher = {Springer Fachmedien},
  location = {Wiesbaden},
  doi = {10.1007/978-3-658-27029-2_20},
  url = {https://doi.org/10.1007/978-3-658-27029-2_20},
  urldate = {2025-02-11},
  abstract = {EinfÃ¼hrung, Wartung und Betrieb von Anwendungssoftware stellt Organisationen nicht selten vor groÃe Herausforderungen. Eine Ursache hierfÃ¼r liegt in der hohen KomplexitÃ¤t von Softwareprojekten. Als Antwort auf diese Herausforderungen wurden in den letzten Jahren in Wissenschaft und Praxis neue LÃ¶sungsansÃ¤tze entwickelt, die sich in gewinnorientierten Unternehmen zunehmend durchsetzen, in Ã¶ffentlichen Verwaltungen aber noch eine exotische Ausnahme bilden. Gemeint sind zum einen agile Projektmanagementmethoden wie SCRUM, zum anderen mit dem Label 4.0 gekennzeichnete AnsÃ¤tze der Selbststeuerung. Damit diese modernen Methoden gelingen, bedarf es Ã¼berdurchschnittlich motivierter und informierter Mitarbeiter. Um die richtigen personellen Ressourcen anzulocken und zu hÃ¶chsten Leistungen zu motivieren, mÃ¼ssen ArbeitsatmosphÃ¤re und VergÃ¼tung im Unternehmen stimmen. Aus der persÃ¶nlichen Erfahrung des Autors heraus werden die Besonderheiten und Unterschiede zwischen dem Unternehmen SAP und der Bundeswehr dargestellt. Am Ende des Beitrags sind Verbesserungspotenziale abgeleitet, die der Ã¶ffentlichen Verwaltung helfen kÃ¶nnen, die Digitalisierung erfolgreich zu gestalten.},
  isbn = {978-3-658-27029-2},
  langid = {ngerman},
  keywords = {AgilitÃ¤t,Bundeswehr,SAP,Scrum},
  file = {C:\Users\Karl\Zotero\storage\9B7L828N\Clasen - 2019 - Der Umgang mit KomplexitÃ¤t bei SAP und Bundeswehr â eine subjektive Betrachtung.pdf}
}

@inproceedings{codabuxManagingTechnicalDebt2013,
  title = {Managing Technical Debt: An Industrial Case Study},
  shorttitle = {Managing Technical Debt},
  booktitle = {Proceedings of the 4th {{International Workshop}} on {{Managing Technical Debt}}},
  author = {Codabux, Zadia and Williams, Byron},
  date = {2013-05-20},
  series = {{{MTD}} '13},
  pages = {8--15},
  publisher = {IEEE Press},
  location = {San Francisco, California},
  abstract = {Technical debt is the consequence of trade-offs made during software development to ensure speedy releases. The research community lacks rigorously evaluated guidelines to help practitioners characterize, manage and prioritize debt. This paper describes a study conducted with an industrial partner during their implementation of Agile development practices for a large software development division within the company. The report contains our initial findings based on ethnographic observations and semi-structured interviews. The goal is to identify the best practices regarding managing technical debt so that the researchers and the practitioners can further evaluate these practices to extend their knowledge of the technical debt metaphor. We determined that the developers considered their own taxonomy of technical debt based on the type of work they were assigned and their personal understanding of the term. Despite management's high-level categories, the developers mostly considered design debt, testing debt and defect debt. In addition to developers having their own taxonomy, assigning dedicated teams for technical debt reduction and allowing other teams about 20\% of time per sprint for debt reduction are good initiatives towards lowering technical debt. While technical debt has become a well-regarded concept in the Agile community, further empirical evaluation is needed to assess how to properly apply the concept for various development organizations.},
  isbn = {978-1-4673-6443-0},
  file = {C:\Users\Karl\Zotero\storage\GHMW43F4\Codabux and Williams - 2013 - Managing technical debt an industrial case study.pdf}
}

@inproceedings{codurEvolutionSoftwareDevelopment2009,
  title = {Evolution of Software Development Standards in the Military Domain and Effects on Software Applications},
  booktitle = {Proceedings of the Joint International and Annual {{ERCIM}} Workshops on {{Principles}} of Software Evolution ({{IWPSE}}) and Software Evolution ({{Evol}}) Workshops},
  author = {Codur, Kemal Burak and Dogru, Ali Hikmet},
  date = {2009-08-24},
  series = {{{IWPSE-Evol}} '09},
  pages = {41--46},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/1595808.1595818},
  url = {https://dl.acm.org/doi/10.1145/1595808.1595818},
  urldate = {2025-02-07},
  abstract = {System life cycle tends to be longer in military applications, reaching over 30 years in specific examples. Development and maintenance of software contained by these systems are regulated by software development standards. Such standards are being utilized since 1978 in the military domain. During recent decades, these standards evolved along with software engineering concepts. This paper presents progress of software development standards in the military domain, with special emphasis on life cycle of applications. This progress is evolutionary, without radical shifts in contents and concepts. Details of the progress provide an insight to the evolution at a conceptual level. Experimental findings regarding the evolution are presented. The study is concluded with comments on the relation between standards' evolution and software applications.},
  isbn = {978-1-60558-678-6},
  file = {C:\Users\Karl\Zotero\storage\9WN8YLXQ\Codur and Dogru - 2009 - Evolution of software development standards in the military domain and effects on software applicati.pdf}
}

@article{cunninghamWyCashPortfolioManagement1992,
  title = {The {{WyCash}} Portfolio Management System},
  shorttitle = {{{WyCash Portfolio}}},
  author = {Cunningham, Ward},
  date = {1992-12-01},
  journaltitle = {SIGPLAN OOPS Mess.},
  volume = {4},
  number = {2},
  pages = {29--30},
  issn = {1055-6400},
  doi = {10.1145/157710.157715},
  url = {https://dl.acm.org/doi/10.1145/157710.157715},
  urldate = {2025-02-17},
  file = {C:\Users\Karl\Zotero\storage\9IMW3SWP\Cunningham - 1992 - The WyCash portfolio management system.pdf}
}

@inproceedings{daleImpactsDesignPattern2014,
  title = {Impacts of Design Pattern Decay on System Quality},
  booktitle = {Proceedings of the 8th {{ACM}}/{{IEEE International Symposium}} on {{Empirical Software Engineering}} and {{Measurement}}},
  author = {Dale, Melissa R. and Izurieta, Clemente},
  date = {2014-09-18},
  pages = {1--4},
  publisher = {ACM},
  location = {Torino Italy},
  doi = {10.1145/2652524.2652560},
  url = {https://dl.acm.org/doi/10.1145/2652524.2652560},
  urldate = {2025-02-07},
  abstract = {Method To investigate this problem, we have developed a grime injector to model grime growth, a form of design pattern decay, on Java projects. We use SonarQubeâs technical debt software to compare the technical debt scores of six diâµerent types of modular grime. These six types can be classified along three major dimensions: strength, scope, and direction. Results We find that the strength dimension is the most important contributor to the quality of a design and that temporary grime results in higher technical debt scores than persistent grime. Conclusion This knowledge helps with design decisions that help manage a projectâs technical debt.},
  eventtitle = {{{ESEM}} '14: 2014 {{ACM-IEEE International Symposium}} on {{Empirical Software Engineering}} and {{Measurement}}},
  isbn = {978-1-4503-2774-9},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\E8NGET4C\Dale and Izurieta - 2014 - Impacts of design pattern decay on system quality.pdf}
}

@article{desilvaControllingSoftwareArchitecture2012,
  title = {Controlling {{Software Architecture Erosion}}: {{A Survey}}},
  shorttitle = {Controlling {{Software Architecture Erosion}}},
  author = {De Silva, Lakshitha Ramesh and Balasubramaniam, Dharini},
  date = {2012-01},
  journaltitle = {Journal of Systems and Software},
  volume = {85},
  number = {1},
  pages = {132--151},
  issn = {0164-1212},
  doi = {10.1016/j.jss.2011.07.036},
  abstract = {Software architectures capture the most significant properties and design constraints of software systems. Thus, modifications to a system that violate its architectural principles can degrade system performance and shorten its useful lifetime. As the potential frequency and scale of software adaptations increase to meet rapidly changing requirements and business conditions, controlling such architecture erosion becomes an important concern for software architects and developers. This paper presents a survey of techniques and technologies that have been proposed over the years either to prevent architecture erosion or to detect and restore architectures that have been eroded. These approaches, which include tools, techniques and processes, are primarily classified into three generic categories that attempt to minimise, prevent and repair architecture erosion. Within these broad categories, each approach is further broken down reflecting the high-level strategies adopted to tackle erosion. These are: process-oriented architecture conformance, architecture evolution management, architecture design enforcement, architecture to implementation linkage, self-adaptation and architecture restoration techniques consisting of recovery, discovery and reconciliation. Some of these strategies contain sub-categories under which survey results are presented.We discuss the merits and weaknesses of each strategy and argue that no single strategy can address the problem of erosion. Further, we explore the possibility of combining strategies and present a case for further work in developing a holistic framework for controlling architecture erosion.},
  file = {C:\Users\Karl\Zotero\storage\CNMCQ5NC\De Silva und Balasubramaniam - 2012 - Controlling Software Architecture Erosion A Survey.pdf}
}

@article{eickDoesCodeDecay2001,
  title = {Does {{Code Decay}}? {{Assessing}} the {{Evidence}} from {{Change Management Data}}},
  shorttitle = {Does {{Code Decay}}?},
  author = {Eick, Stephen G. and Graves, Todd L. and Karr, Alan F. and Marron, J. S. and Mockus, Audris},
  date = {2001-01-01},
  journaltitle = {IEEE Trans. Softw. Eng.},
  volume = {27},
  number = {1},
  pages = {1--12},
  issn = {0098-5589},
  doi = {10.1109/32.895984},
  url = {https://doi.org/10.1109/32.895984},
  urldate = {2025-03-05},
  abstract = {A central feature of the evolution of large software systems is that change which is necessary to add new functionality, accommodate new hardware, and repair faults becomes increasingly difficult over time. In this paper, we approach this phenomenon, which we term code decay, scientifically and statistically. We define code decay and propose a number of measurements (code decay indices) on software and on the organizations that produce it, that serve as symptoms, risk factors, and predictors of decay. Using an unusually rich data set (the fifteen-plus year change history of the millions of lines of software for a telephone switching system), we find mixed, but on the whole persuasive, statistical evidence of code decay, which is corroborated by developers of the code. Suggestive indications that perfective maintenance can retard code decay are also discussed.},
  file = {C:\Users\Karl\Zotero\storage\UTH3ZPSK\Eick et al. - 2001 - Does Code Decay Assessing the Evidence from Change Management Data.pdf}
}

@inproceedings{ernstMeasureItManage2015,
  title = {Measure It? {{Manage}} It? {{Ignore}} It? Software Practitioners and Technical Debt},
  shorttitle = {Measure It?},
  booktitle = {Proceedings of the 2015 10th {{Joint Meeting}} on {{Foundations}} of {{Software Engineering}}},
  author = {Ernst, Neil A. and Bellomo, Stephany and Ozkaya, Ipek and Nord, Robert L. and Gorton, Ian},
  date = {2015-08-30},
  series = {{{ESEC}}/{{FSE}} 2015},
  pages = {50--60},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/2786805.2786848},
  url = {https://dl.acm.org/doi/10.1145/2786805.2786848},
  urldate = {2025-03-17},
  abstract = {The technical debt metaphor is widely used to encapsulate numerous software quality problems. The metaphor is attractive to practitioners as it communicates to both technical and nontechnical audiences that if quality problems are not addressed, things may get worse. However, it is unclear whether there are practices that move this metaphor beyond a mere communication mechanism. Existing studies of technical debt have largely focused on code metrics and small surveys of developers. In this paper, we report on our survey of 1,831 participants, primarily software engineers and architects working in long-lived, software-intensive projects from three large organizations, and follow-up interviews of seven software engineers. We analyzed our data using both nonparametric statistics and qualitative text analysis. We found that architectural decisions are the most important source of technical debt. Furthermore, while respondents believe the metaphor is itself important for communication, existing tools are not currently helpful in managing the details. We use our results to motivate a technical debt timeline to focus management and tooling approaches.},
  isbn = {978-1-4503-3675-8},
  file = {C:\Users\Karl\Zotero\storage\65PE6UUD\Ernst et al. - 2015 - Measure it Manage it Ignore it software practitioners and technical debt.pdf}
}

@online{ExploratoryStudySelfAdmitted,
  title = {An {{Exploratory Study}} on {{Self-Admitted Technical Debt}} | {{IEEE Conference Publication}} | {{IEEE Xplore}}},
  url = {https://ieeexplore.ieee.org/document/6976075},
  urldate = {2025-03-12},
  file = {C:\Users\Karl\Zotero\storage\RUAYBS56\6976075.html}
}

@article{faganDesignCodeInspections1976,
  title = {Design and Code Inspections to Reduce Errors in Program Development},
  shorttitle = {Code {{Inspections}}},
  author = {Fagan, Michael E.},
  date = {1976-09-01},
  journaltitle = {IBM Syst. J.},
  volume = {15},
  number = {3},
  pages = {182--211},
  issn = {0018-8670},
  doi = {10.1147/sj.153.0182},
  url = {https://doi.org/10.1147/sj.153.0182},
  urldate = {2025-03-21},
  abstract = {Substantial net improvements in programming quality and productivity have been obtained through the use of formal inspections of design and of code. Improvements are made possible by a systematic and efficient design and code verification process, with well-defined roles for inspection participants. The manner in which inspection data is categorized and made suitable for process analysis is an important factor in attaining the improvements. It is shown that by using inspection results, a mechanism for initial error reduction followed by ever-improving error rates can be achieved.},
  file = {C:\Users\Karl\Zotero\storage\EDSAGN5M\Fagan - 1976 - Design and code inspections to reduce errors in program development.pdf}
}

@article{feitosaCorrelatingPatternGrime2018,
  title = {Correlating {{Pattern Grime}} and {{Quality Attributes}}},
  author = {Feitosa, D. and Ampatzoglou, A. and Avgeriou, P. and Nakagawa, E.Y.},
  date = {2018-01-01},
  journaltitle = {IEEE Access, Access, IEEE},
  volume = {6},
  pages = {23065--23078},
  publisher = {IEEE},
  issn = {21693536},
  doi = {10.1109/ACCESS.2018.2829895},
  url = {https://research.ebsco.com/linkprocessor/plink?id=5c9db2cd-42b6-371b-9b17-fcb7c0bfc972},
  urldate = {2025-02-03},
  abstract = {The gang of four design patterns are widely adopted in industry as best practices and their effect on software quality has been long investigated in academia, with both positive and negative consequences being observed. One important parameter that relates to the effect of patterns on quality is the deterioration of pattern instances due to the buildup of artifacts unrelated to the pattern structure. This is called pattern grime and can potentially diminish some of the benefits of using patterns in the first place. In this paper we investigate the relation between pattern grime and three qualities, namely performance, security, and correctness. To this end, we conducted a case study with five industrial projects (approx. 260 000 lines of code) implemented by 16 developers. Our findings suggest a correlation between the accumulation of grime and decreased levels of performance, security, and correctness. Moreover, factors such as the project itself, pattern type and the developer can influence this relation. The obtained results can benefit both researchers and practitioners, as we provide evidence on the accumulation of pattern grime and its correlation to performance, security and correctness, and how different factors affect these correlations.},
  keywords = {Aerospace,Bioengineering,Communication Networking and Broadcast Technologies,Components Circuits Devices and Systems,Computing and Processing,Correlation,Data mining,Degradation,Design patterns,Engineered Materials Dielectrics and Plasmas,Engineering Profession,Fields Waves and Electromagnetics,General Topics for Engineers,Geoscience,industrial case study,Nuclear Engineering,Open source software,pattern grime,Photonics and Electrooptics,Power Energy and Industry Applications,quality attributes,Robotics and Control Systems,Security,Signal Processing and Analysis,Software quality,Software systems,Transportation},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\IZNJ6B83\\Feitosa et al. - 2018 - Correlating Pattern Grime and Quality Attributes.pdf;C\:\\Users\\Karl\\Zotero\\storage\\SMKP3XZY\\Feitosa et al. - 2018 - Correlating Pattern Grime and Quality Attributes.pdf}
}

@online{fowlerContinuousIntegration2006,
  title = {Continuous {{Integration}}},
  author = {Fowler, Martin},
  date = {2006},
  url = {https://martinfowler.com/articles/continuousIntegration.html},
  urldate = {2025-03-18},
  abstract = {Every developer integrates their work into mainline at least every day.},
  organization = {martinfowler.com},
  file = {C:\Users\Karl\Zotero\storage\3XDKJXUS\continuousIntegration.html}
}

@article{fowlerRefactoringImprovingDesign,
  title = {Refactoring - {{Improving}} the {{Design}} of {{Existing Code}}},
  author = {Fowler, Martin and Beck, Kent and Brant, John},
  langid = {english}
}

@book{fowlerRefactoringImprovingDesign2012,
  title = {Refactoring: {{Improving}} the {{Design}} of {{Existing Code}}},
  shorttitle = {Refactoring},
  author = {Fowler, Martin and Beck, Kent and Brant, John and Opdyke, William and Roberts, Don},
  date = {2012-03-09},
  eprint = {HmrDHwgkbPsC},
  eprinttype = {googlebooks},
  publisher = {Addison-Wesley},
  abstract = {As the application of object technology--particularly the Java programming language--has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, "non-optimal" applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as "refactoring," these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Code, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process.    With proper training a skilled system designer can take a bad design and rework it into well-designed, robust code. In this book, Martin Fowler shows you where opportunities for refactoring typically can be found, and how to go about reworking a bad design into a good one. Each refactoring step is simple--seemingly too simple to be worth doing. Refactoring may involve moving a field from one class to another, or pulling some code out of a method to turn it into its own method, or even pushing some code up or down a hierarchy. While these individual steps may seem elementary, the cumulative effect of such small changes can radically improve the design. Refactoring is a proven way to prevent software decay.    In addition to discussing the various techniques of refactoring, the author provides a detailed catalog of more than seventy proven refactorings with helpful pointers that teach you when to apply them; step-by-step instructions for applying each refactoring; and an example illustrating how the refactoring works. The illustrative examples are written in Java, but the ideas are applicable to any object-oriented programming language.},
  isbn = {978-0-13-306526-8},
  langid = {english},
  pagetotal = {461},
  keywords = {Computers / Programming / Object Oriented}
}

@book{fowlerRefactoringImprovingDesign2019,
  title = {Refactoring: {{Improving}} the {{Design}} of {{Existing Code}}},
  shorttitle = {Refactoring},
  author = {Fowler, Martin},
  date = {2019},
  eprint = {o69NtAEACAAJ},
  eprinttype = {googlebooks},
  publisher = {Addison-Wesley},
  abstract = {Martin Fowler's guide to reworking bad code into well-structured code Refactoring improves the design of existing code and enhances software maintainability, as well as making existing code easier to understand. Original Agile Manifesto signer and software development thought leader, Martin Fowler, provides a catalog of refactorings that explains why you should refactor; how to recognize code that needs refactoring; and how to actually do it successfully, no matter what language you use.  Refactoring principles: understand the process and general principles of refactoring Code smells: recognize "bad smells" in code that signal opportunities to refactor Application improvement: quickly apply useful refactorings to make a program easier to comprehend and change Building tests: writing good tests increases a programmer's effectiveness Moving features: an important part of refactoring is moving elements between contexts Data structures: a collection of refactorings to organize data, an important role in programs Conditional Logic: use refactorings to make conditional sections easier to understand APIs: modules and their functions are the building blocks of our software, and APIs are the joints that we use to plug them together Inheritance: it is both very useful and easy to misuse, and it's often hard to see the misuse until it's in the rear-view mirror---refactorings can fix the misuse  Examples are written in JavaScript, but you shouldn't find it difficult to adapt the refactorings to whatever language you are currently using as they look mostly the same in different languages. "Whenever you read [Refactoring], it's time to read it again. And if you haven't read it yet, please do before writing another line of code." -David Heinemeier Hansson, Creator of Ruby on Rails, Founder \& CTO at Basecamp "Any fool can write code that a computer can understand. Good programmers write code that humans can understand." -M. Fowler (1999)},
  isbn = {978-0-13-475759-9},
  langid = {english},
  keywords = {Computers / Programming / Object Oriented,Computers / Software Development & Engineering / General,Computers / Software Development & Engineering / Systems Analysis & Design},
  file = {C:\Users\Karl\Zotero\storage\WR5EB5PH\Fowler - 2019 - Refactoring Improving the Design of Existing Code.pdf}
}

@online{fowlerTechnicalDebtQuadrant2009,
  title = {Technical {{Debt Quadrant}}},
  author = {Fowler, Martin},
  date = {2009-10-14},
  url = {https://martinfowler.com/bliki/TechnicalDebtQuadrant.html},
  urldate = {2025-03-10},
  abstract = {People argue about whether some kinds of bad code count as Technical Debt. I prefer to focus on the interest/principal decision, and recognize debt has different causes.},
  organization = {martinfowler.com},
  file = {C:\Users\Karl\Zotero\storage\ITTPFA7S\TechnicalDebtQuadrant.html}
}

@book{gammaDesignPatternsElements1995,
  title = {Design Patterns: Elements of Reusable Object-Oriented Software},
  shorttitle = {Design Patterns},
  author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John},
  date = {1995},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  location = {USA},
  isbn = {978-0-201-63361-0},
  pagetotal = {395},
  file = {C:\Users\Karl\Zotero\storage\EUV4BJ3H\articulo.pdf}
}

@inproceedings{gurpDesignErosionProblems2001,
  title = {Design {{Erosion}}: {{Problems}} \& {{Causes}}},
  shorttitle = {Design {{Erosion}}},
  author = {Gurp, J. V. and Bosch, J.},
  date = {2001},
  url = {https://www.semanticscholar.org/paper/Design-Erosion%3A-Problems-%26-Causes-Gurp-Bosch/6368e6812af998df3ac72ffdb34378ae340920bd},
  urldate = {2025-02-07},
  abstract = {Design erosion is a common problem in software engineering. We have found that invariably, no matter how ambitious the intentions of the designers were, software designs tend to erode over time to the point that redesigning from scratch becomes a viable alternative compared to prolonging the life of the existing design. In this paper we illustrate how design erosion works by presenting the evolution of the design of a small software system. In our analysis of this example we show how design decisions accumalate and become invalid because of new requirements. Also it is argued that even an optimal strategy for designing the system (i.e. no compromises with respect to e.g. cost are made) does not lead to an optimal design because of unforseen requirement changes that invalidate design decisions that once were optimal.},
  file = {C:\Users\Karl\Zotero\storage\S2KS5F3R\Gurp and Bosch - 2001 - Design Erosion Problems & Causes.pdf}
}

@inproceedings{hiltonTradeoffsContinuousIntegration2017,
  title = {Trade-Offs in Continuous Integration: Assurance, Security, and Flexibility},
  shorttitle = {Trade-Offs in Continuous Integration},
  booktitle = {Proceedings of the 2017 11th {{Joint Meeting}} on {{Foundations}} of {{Software Engineering}}},
  author = {Hilton, Michael and Nelson, Nicholas and Tunnell, Timothy and Marinov, Darko and Dig, Danny},
  date = {2017-08-21},
  series = {{{ESEC}}/{{FSE}} 2017},
  pages = {197--207},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/3106237.3106270},
  url = {https://dl.acm.org/doi/10.1145/3106237.3106270},
  urldate = {2025-03-18},
  abstract = {Continuous integration (CI) systems automate the compilation, building, and testing of software. Despite CI being a widely used activity in software engineering, we do not know what motivates developers to use CI, and what barriers and unmet needs they face. Without such knowledge, developers make easily avoidable errors, tool builders invest in the wrong direction, and researchers miss opportunities for improving the practice of CI. We present a qualitative study of the barriers and needs developers face when using CI. We conduct semi-structured interviews with developers from different industries and development scales. We triangulate our findings by running two surveys. We find that developers face trade-offs between speed and certainty (Assurance), between better access and information security (Security), and between more configuration options and greater ease of use (Flexi- bility). We present implications of these trade-offs for developers, tool builders, and researchers.},
  isbn = {978-1-4503-5105-8},
  file = {C:\Users\Karl\Zotero\storage\G2XN5PTH\Hilton et al. - 2017 - Trade-offs in continuous integration assurance, security, and flexibility.pdf}
}

@book{humbleContinuousDeliveryReliable2010,
  title = {Continuous {{Delivery}}: {{Reliable Software Releases Through Build}}, {{Test}}, and {{Deployment Automation}}},
  shorttitle = {Continuous {{Delivery}}},
  author = {Humble, Jez and Farley, David},
  date = {2010},
  eprint = {9CAxmQEACAAJ},
  eprinttype = {googlebooks},
  publisher = {Addison-Wesley},
  abstract = {Winner of the 2011 Jolt Excellence Award!   Getting software released to users is often a painful, risky, and time-consuming process. This groundbreaking new book sets out the principles and technical practices that enable rapid, incremental delivery of high quality, valuable new functionality to users. Through automation of the build, deployment, and testing process, and improved collaboration between developers, testers, and operations, delivery teams can get changes released in a matter of hoursâ sometimes even minutesâno matter what the size of a project or the complexity of its code base.   Jez Humble and David Farley begin by presenting the foundations of a rapid, reliable, low-risk delivery process. Next, they introduce the âdeployment pipeline,â an automated process for managing all changes, from check-in to release. Finally, they discuss the âecosystemâ needed to support continuous delivery, from infrastructure, data and configuration management to governance.   The authors introduce state-of-the-art techniques, including automated infrastructure management and data migration, and the use of virtualization. For each, they review key issues, identify best practices, and demonstrate how to mitigate risks. Coverage includes   â¢ Automating all facets of building, integrating, testing, and deploying software â¢ Implementing deployment pipelines at team and organizational levels â¢ Improving collaboration between developers, testers, and operations â¢ Developing features incrementally on large and distributed teams â¢ Implementing an effective configuration management strategy â¢ Automating acceptance testing, from analysis to implementation â¢ Testing capacity and other non-functional requirements â¢ Implementing continuous deployment and zero-downtime releases â¢ Managing infrastructure, data, components and dependencies â¢ Navigating risk management, compliance, and auditing   Whether you're a developer, systems administrator, tester, or manager, this book will help your organization move from idea to release faster than everâso you can deliver value to your business rapidly and reliably.},
  isbn = {978-0-321-60191-9},
  langid = {english},
  keywords = {Computers / Programming / General,Computers / Software Development & Engineering / General},
  file = {C:\Users\Karl\Zotero\storage\KDHJM8FC\Humble and Farley - 2010 - Continuous Delivery Reliable Software Releases Through Build, Test, and Deployment Automation.pdf}
}

@online{ImpactsDesignPattern,
  title = {Impacts of Design Pattern Decay on System Quality | {{Request PDF}}},
  doi = {10.1145/2652524.2652560},
  url = {https://www.researchgate.net/publication/266661826_Impacts_of_design_pattern_decay_on_system_quality},
  urldate = {2025-02-07},
  abstract = {Request PDF | Impacts of design pattern decay on system quality | Context Software systems need to be of high enough quality to enable growth and stability. Goal The purpose of this research is to study the... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  organization = {ResearchGate},
  file = {C:\Users\Karl\Zotero\storage\ZKRCATNC\266661826_Impacts_of_design_pattern_decay_on_system_quality.html}
}

@inproceedings{inproceedings,
  title = {Effects of Test-Driven Development: A Comparative Analysis of Empirical Studies},
  shorttitle = {Effects of {{TDD}}},
  author = {MÃ¤kinen, Simo and MÃ¼nch, JÃ¼rgen},
  date = {2014-01},
  series = {Lecture {{Notes}} in {{Business Information Processing}}},
  volume = {166},
  doi = {10.1007/978-3-319-03602-1_10},
  isbn = {978-3-319-03601-4},
  file = {C:\Users\Karl\Zotero\storage\XIC7TE38\Makinen and MÃ¼nch - 2014 - Effects of test-driven development a comparative analysis of empirical studies.pdf}
}

@online{InvestigatingViolationsRoles,
  title = {Toward {{Investigating}} the {{Violations Roles}} of {{Pattern Grime Occurrence}} in {{Software Design Patterns}}},
  url = {https://explore.openaire.eu/search/publication?pid=10.1145%2F3530019.3535347},
  urldate = {2025-02-03},
  abstract = {Toward Investigating the Violations Roles of Pattern Grime Occurrence in Software Design Patterns},
  langid = {english},
  organization = {OpenAIRE - Explore},
  file = {C:\Users\Karl\Zotero\storage\XBZVZI4Z\publication.html}
}

@online{ITGrundschutz,
  title = {{{IT-Grundschutz}}},
  url = {https://www.bsi.bund.de/EN/Themen/Unternehmen-und-Organisationen/Standards-und-Zertifizierung/IT-Grundschutz/it-grundschutz.html?nn=908032},
  urldate = {2025-03-26},
  langid = {english},
  organization = {Federal Office for Information Security},
  file = {C:\Users\Karl\Zotero\storage\UZCBK84Q\it-grundschutz_node.html}
}

@article{izurietaHowSoftwareDesigns2007,
  title = {How {{Software Designs Decay}}: {{A Pilot Study}} of {{Pattern Evolution}}},
  shorttitle = {How {{Software Designs Decay}}},
  author = {Izurieta, Clemente and Bieman, James M.},
  date = {2007-09-01},
  journaltitle = {First International Symposium on Empirical Software Engineering and Measurement (ESEM 2007), Empirical Software Engineering and Measurement, 2007. ESEM 2007. First International Symposium on},
  pages = {449--451},
  publisher = {IEEE},
  issn = {978-0-7695-2886-1},
  doi = {10.1109/ESEM.2007.55},
  url = {https://research.ebsco.com/linkprocessor/plink?id=033bf7e0-eb1f-3532-83a1-c548bfa3639c},
  urldate = {2025-02-03},
  abstract = {A common belief is that software designs decay as systems evolve. This research examines the extent to which software designs actually decay by studying the aging of design patterns in successful object oriented systems. Aging of design patterns is measured using various types of decay indices developed for this research. Decay indices track the internal structural changes of a design pattern realization and the code that surrounds the realization. Hypotheses for each kind of decay are tested. We found that the original design pattern functionality remains, and pattern decay is due to the "grime", non-pattern code, that grows around the pattern realization.},
  keywords = {Aging,Computer science,Computing and Processing,Cost function,Decay,Evolution,Open source software,Open Source Software,Permission,Software,Software design,Software engineering,Software Engineering,Software Grime Buildup.,Software measurement,Software systems,Testing},
  file = {C:\Users\Karl\Zotero\storage\FMFX53GV\Izurieta und Bieman - 2007 - How Software Designs Decay A Pilot Study of Pattern Evolution.pdf}
}

@article{izurietaMultipleCaseStudy2013,
  title = {A Multiple Case Study of Design Pattern Decay, Grime, and Rot in Evolving Software Systems},
  author = {Izurieta, Clemente and Bieman, James M.},
  date = {2013-06-01},
  journaltitle = {Software Quality Journal},
  shortjournal = {Software Quality Journal},
  volume = {21},
  number = {2},
  pages = {289--323},
  publisher = {Springer US},
  location = {Boston},
  issn = {09639314},
  doi = {10.1007/s11219-012-9175-x},
  url = {https://research.ebsco.com/linkprocessor/plink?id=558abecc-02d2-38d7-9ecb-98f406c71016},
  abstract = {Software designs decay as systems, uses, and operational environments evolve. Decay can involve the design patterns used to structure a system. Classes that participate in design pattern realizations accumulate grimeânon-pattern-related code. Design pattern realizations can also rot, when changes break the structural or functional integrity of a design pattern. Design pattern rot can prevent a pattern realization from fulfilling its responsibilities, and thus represents a fault. Grime buildup does not break the structural integrity of a pattern but can reduce system testability and adaptability. This research examined the extent to which software designs actually decay, rot, and accumulate grime by studying the aging of design patterns in three successful object-oriented systems. We generated UML models from the three implementations and employed a multiple case study methodology to analyze the evolution of the designs. We found no evidence of design pattern rot in these systems. However, we found considerable evidence of pattern decay due to grime. Dependencies between design pattern components increased without regard for pattern intent, reducing pattern modularity, and decreasing testability and adaptability. The study of decay and grime showed that the grime that builds up around design patterns is mostly due to increases in coupling.{$<$}br /{$>$}},
  langid = {english},
  keywords = {Decay,Design concepts,Design patterns,Grime,Multiple case study,Object-oriented design methods,Software evolution,Technical debt},
  file = {C:\Users\Karl\Zotero\storage\LQBVGR7J\Izurieta und Bieman - 2013 - A multiple case study of design pattern decay, grime, and rot in evolving software systems.pdf}
}

@article{kimEmpiricalStudyRefactoringChallenges2014,
  title = {An {{Empirical Study}} of {{RefactoringChallenges}} and {{Benefits}} at {{Microsoft}}},
  shorttitle = {Refactoring {{Challenges}}},
  author = {Kim, Miryung and Zimmermann, Thomas and Nagappan, Nachiappan},
  date = {2014-07},
  journaltitle = {IEEE Transactions on Software Engineering},
  volume = {40},
  number = {7},
  pages = {633--649},
  issn = {1939-3520},
  doi = {10.1109/TSE.2014.2318734},
  url = {https://ieeexplore.ieee.org/document/6802406},
  urldate = {2025-03-19},
  abstract = {It is widely believed that refactoring improves software quality and developer productivity. However, few empirical studies quantitatively assess refactoring benefits or investigate developersâ perception towards these benefits. This paper presents a field study of refactoring benefits and challenges at Microsoft through three complementary study methods: a survey, semi-structured interviews with professional software engineers, and quantitative analysis of version history data. Our survey finds that the refactoring definition in practice is not confined to a rigorous definition of semantics-preserving code transformations and that developers perceive that refactoring involves substantial cost and risks. We also report on interviews with a designated refactoring team that has led a multi-year, centralized effort on refactoring Windows. The quantitative analysis of Windows 7 version history finds the top 5 percent of preferentially refactored modules experience higher reduction in the number of inter-module dependencies and several complexity measures but increase size more than the bottom 95 percent. This indicates that measuring the impact of refactoring requires multi-dimensional assessment.},
  eventtitle = {{{IEEE Transactions}} on {{Software Engineering}}},
  keywords = {churn,Complexity theory,component dependencies,Computer bugs,defects,empirical study,History,Interviews,Refactoring,Size measurement,Software,software evolution,Software metrics},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\LI5JDEWN\\Kim et al. - 2014 - An Empirical Study of RefactoringChallenges and Benefits at Microsoft.pdf;C\:\\Users\\Karl\\Zotero\\storage\\FLT9E78F\\6802406.html}
}

@inproceedings{kitchenhamSystematicReviewSoftware2012,
  title = {Systematic Review in Software Engineering: Where We Are and Where We Should Be Going},
  shorttitle = {Systematic Review in Software Engineering},
  booktitle = {Proceedings of the 2nd International Workshop on {{Evidential}} Assessment of Software Technologies},
  author = {Kitchenham, Barbara A.},
  date = {2012-09-22},
  series = {{{EAST}} '12},
  pages = {1--2},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/2372233.2372235},
  url = {https://dl.acm.org/doi/10.1145/2372233.2372235},
  urldate = {2025-02-19},
  abstract = {In 2004 Kitchenham et al. first proposed the idea of evidence-based software engineering (EBSE). EBSE requires a systematic and unbiased method of aggregating empirical studies and has encouraged software engineering researches to undertake systematic literature reviews (SLRs) of Software Engineering topics and research questions. As software engineers began to use the SLR technology, they also began to comment on the SLR process itself. Brereton et al (2007) was one of the first papers that commented on issues connected with performing SLRs and many such papers have followed since covering topics such as: The use of SLRs in education; Experiences of novices using SLRs; The adoption of mapping and scoping studies; The repeatability of SLRs; Improving the search and selection processes; Quality assessment of primary studies; Improving aggregation processes.It therefore seems appropriate to identify the current status of such studies in software engineering, and identify whether there is evidence for revising and/or extending the guidelines for performing systematic literature reviews (Kitchenham and Charters, 2007). This keynote will report the current results of an ongoing systematic literature review that aims: A1: To identify and categorise papers investigating the SLR process and the claims relating to that process; A2: To identify the extent to which the claims of repeatability, lack of bias, and openness are supported; A3: To identify any areas where current guidelines need to be amended or extended to reflect current knowledge of applying SLRs in the context of software engineering.},
  isbn = {978-1-4503-1509-8},
  file = {C:\Users\Karl\Zotero\storage\BRYUK9GX\Kitchenham - 2012 - Systematic review in software engineering where we are and where we should be going.pdf}
}

@article{kleinwaksOntologyTechnicalDebt2023,
  title = {Ontology for {{Technical Debt}} in {{Systems Engineering}}},
  author = {Kleinwaks, Howard and Batchelor, Ann and Bradley, Thomas H.},
  date = {2023},
  journaltitle = {IEEE Open Journal of Systems Engineering},
  volume = {1},
  pages = {111--122},
  issn = {2771-9987},
  doi = {10.1109/OJSE.2023.3316395},
  url = {https://ieeexplore.ieee.org/document/10254240/?arnumber=10254240},
  urldate = {2025-02-17},
  abstract = {The technical debt metaphor is used to describe the long-term consequences of engineering decisions made to achieve a short-term benefit. The metaphor originated in the field of software engineering and has begun to migrate to other fields, including systems engineering. The usage of the metaphor, its associated terminology, and basic definitions vary both within the software field and within the greater engineering community. The lack of consistent definitions inhibits the ability of system developers to understand and control technical debt within their system developments. This article presents an ontology for technical debt, focusing on the field of systems engineering. By providing a set of concise and consolidated definitions, this ontology enables precise discussion of technical debt and associated techniques for mitigating its impact within systems engineering.},
  eventtitle = {{{IEEE Open Journal}} of {{Systems Engineering}}},
  keywords = {Ontologies,Ontology,rework,Software engineering,systems engineering,Systems engineering and theory,Taxonomy,technical debt (TD),Terminology},
  file = {C:\Users\Karl\Zotero\storage\8ZTST5TA\10254240.html}
}

@article{kleinwaksTechnicalDebtSystems2023,
  title = {Technical Debt in Systems Engineeringâ{{A}} Systematic Literature Review.},
  author = {Kleinwaks, Howard and Batchelor, Ann and Bradley, Thomas H.},
  date = {2023-09-01},
  journaltitle = {Systems Engineering},
  shortjournal = {Systems Engineering},
  volume = {26},
  number = {5},
  pages = {675--687},
  publisher = {Wiley-Blackwell},
  issn = {1098-1241},
  doi = {10.1002/sys.21681},
  url = {https://research.ebsco.com/linkprocessor/plink?id=0f83e454-a27c-34d5-b50f-11ba91d1be25},
  urldate = {2025-02-17},
  abstract = {The metaphor of "technical debt" is used in software engineering to describe technical solutions that may be pragmatic in the nearâterm but may have a negative longâterm impact. Similar decisions and similar dynamics are present in the field of systems engineering. This work investigates the current body of knowledge to identify if, and how, the technical debt metaphor is used within the systems engineering field and which systems engineering lifecycle stages are most susceptible to technical debt. A systematic literature review was conducted on 354 papers in February 2022, of which 18 were deemed relevant for inclusion in the study. The results of the systematic literature review show that the technical debt metaphor is not prevalent within systems engineering research and that existing research is limited to specific fields and theoretical discussions. This paper concludes with recommendations for future work to establish a research agenda on the identification and management of technical debt within systems engineering.},
  langid = {english},
  keywords = {DEBT management,PRAGMATICS,SOFTWARE engineering,SYSTEMS engineering},
  file = {C:\Users\Karl\Zotero\storage\6CLWFUL6\Kleinwaks et al. - 2023 - Technical debt in systems engineeringâA systematic literature review..pdf}
}

@book{kruchtenManagingTechnicalDebt2019,
  title = {Managing {{Technical Debt}}: {{Reducing Friction}} in {{Software Development}}},
  shorttitle = {Managing {{Technical Debt}}},
  author = {Kruchten, Philippe and Ozkaya, Ipek},
  date = {2019-04-15},
  eprint = {R3qSDwAAQBAJ},
  eprinttype = {googlebooks},
  publisher = {Pearson Education},
  abstract = {âThis is an incredibly wise and useful book. The authors have considerable real-world experience in delivering quality systems that matter, and their expertise shines through in these pages. Here you will learn what technical debt is, what is it not, how to manage it, and how to pay it down in responsible ways. This is a book I wish I had when I was just beginning my career. The authors present a myriad of case studies, born from years of experience, and offer a multitude of actionable insights for how to apply it to your project.â âGrady Booch, IBM Fellow  Master Best Practices for Managing Technical Debt to Promote Software Quality and Productivity As software systems mature, earlier design or code decisions made in the context of budget or schedule constraints increasingly impede evolution and innovation. This phenomenon is called technical debt, and practical solutions exist. In Managing Technical Debt, three leading experts introduce integrated, empirically developed principles and practices that any software professional can use to gain control of technical debt in any software system.  Using real-life examples, the authors explain the forms of technical debt that afflict software-intensive systems, their root causes, and their impacts. They introduce proven approaches for identifying and assessing specific sources of technical debt, limiting new debt, and âpaying offâ debt over time. They describe how to establish managing technical debt as a core software engineering practice in your organization.   Discover how technical debt damages manageability, quality, productivity, and moraleâand what you can do about it Clarify root causes of debt, including the linked roles of business goals, source code, architecture, testing, and infrastructure Identify technical debt items, and analyze their costs so you can prioritize action Choose the right solution for each technical debt item: eliminate, reduce, or mitigate Integrate software engineering practices that minimize new debt   Managing Technical Debt will be a valuable resource for every software professional who wants to accelerate innovation in existing systems, or build new systems that will be easier to maintain and evolve.},
  isbn = {978-0-13-564596-3},
  langid = {english},
  pagetotal = {327},
  keywords = {Computers / Software Development & Engineering / General,Computers / Software Development & Engineering / Quality Assurance & Testing}
}

@article{kruchtenTechnicalDebtMetaphor2012,
  title = {Technical {{Debt}}: {{From Metaphor}} to {{Theory}} and {{Practice}}},
  shorttitle = {Technical {{Debt}}},
  author = {Kruchten, Philippe and Nord, Robert L. and Ozkaya, Ipek},
  date = {2012-11},
  journaltitle = {IEEE Software},
  volume = {29},
  number = {6},
  pages = {18--21},
  issn = {1937-4194},
  doi = {10.1109/MS.2012.167},
  url = {https://ieeexplore.ieee.org/document/6336722},
  urldate = {2025-03-11},
  abstract = {The metaphor of technical debt in software development was introduced two decades ago to explain to nontechnical stakeholders the need for what we call now "refactoring." As the term is being used to describe a wide range of phenomena, this paper proposes an organization of the technical debt landscape, and introduces the papers on technical debt contained in the issue.},
  eventtitle = {{{IEEE Software}}},
  keywords = {evolvability,Investments,maintainability,refactoring,Risk management,Software maintenance,software quality,Software quality,Sofware testing,technical debt},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\ZCJVNT8C\\Kruchten et al. - 2012 - Technical Debt From Metaphor to Theory and Practice.pdf;C\:\\Users\\Karl\\Zotero\\storage\\6DZI7LM8\\6336722.html}
}

@inproceedings{landSoftwareDeteriorationMaintainability2002,
  title = {Software {{Deterioration And Maintainability}} - {{A Model Proposal}} | {{Request PDF}}},
  shorttitle = {Software {{Deterioration}}},
  author = {Land, Rikard},
  date = {2002},
  url = {https://www.researchgate.net/publication/2540166_Software_Deterioration_And_Maintainability_-_A_Model_Proposal},
  urldate = {2025-03-21},
  abstract = {Request PDF | Software Deterioration And Maintainability - A Model Proposal | In this paper, we connect the notion of software maintainability with the problem of software deterioration. We propose a model that incorporates... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\G7CXEWR4\\Land - 2002 - Software Deterioration And Maintainability - A Model Proposal  Request PDF.pdf;C\:\\Users\\Karl\\Zotero\\storage\\W3NWLA5I\\2540166_Software_Deterioration_And_Maintainability_-_A_Model_Proposal.html}
}

@online{landSoftwareDeteriorationMaintainability2002a,
  title = {Software {{Deterioration And Maintainability}} â {{A Model Proposal}}},
  author = {Land, R.},
  date = {2002},
  url = {https://www.semanticscholar.org/paper/Software-Deterioration-And-Maintainability-%E2%80%93-A-Land/c3cf69807970417604bc9c346afe197f5c3b6a63},
  urldate = {2025-03-21},
  abstract = {A model that incorporates both the notion of software maintainability and the problem of software deterioration is proposed, which gives a vocabulary and a more formal tool than before and suggests ways of verifying it. In this paper, we connect the notion of software maintainability with the problem of software deterioration. We propose a model that incorporates both of these aspects, which gives us a vocabulary and a more formal tool than before, and allows us to discuss how to maint ain software so as not to make it deteriorate. This paper describes the problem areas of software maintenance and software deterioration, describes the proposed model, and suggests ways of verifying it.},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\E5VCM2S3\c3cf69807970417604bc9c346afe197f5c3b6a63.html}
}

@inproceedings{lehmanProgramsCitiesStudents1978,
  title = {Programs, {{Cities}}, {{Students}}â {{Limits}} to {{Growth}}?},
  booktitle = {Programming {{Methodology}}},
  author = {Lehman, M. M.},
  editor = {Gries, David},
  date = {1978},
  pages = {42--69},
  publisher = {Springer New York},
  location = {New York, NY},
  doi = {10.1007/978-1-4612-6315-9_6},
  url = {http://link.springer.com/10.1007/978-1-4612-6315-9_6},
  urldate = {2025-03-06},
  abstract = {In an invited lecture to the 1971 IFIP Congress [Randell 71b*], Brian Randell of the University of Newcastle typified the situation current in the design, implementation and maintenance of computer software systems by showing a slide (Plate I)1 of a medieval battlefield with ranks aligned but carnage abounding and devastation everywhere.},
  isbn = {978-1-4612-6317-3 978-1-4612-6315-9}
}

@article{lehmanProgramsLifeCycles1980,
  title = {Programs, Life Cycles, and Laws of Software Evolution},
  author = {Lehman, Meir M.},
  date = {1980-09},
  journaltitle = {Proceedings of the IEEE},
  volume = {68},
  number = {9},
  pages = {1060--1076},
  issn = {1558-2256},
  doi = {10.1109/PROC.1980.11805},
  url = {https://ieeexplore.ieee.org/document/1456074},
  urldate = {2025-02-07},
  abstract = {By classifying programs according to their relationship to the environment in which they are executed, the paper identifies the sources of evolutionary pressure on computer applications and programs and shows why this results in a process of never ending maintenance activity. The resultant life cycle processes are then briefly discussed. The paper then introduces laws of Program Evolution that have been formulated following quantitative studies of the evolution of a number of different systems. Finally an example is provided of the application of Evolution Dynamics models to program release planning.},
  eventtitle = {Proceedings of the {{IEEE}}},
  keywords = {Application software,Automatic programming,Computer applications,Economic indicators,Environmental economics,Fabrics,Microprocessors,Productivity,Software maintenance},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\QSQU4BVX\\lehman.pdf;C\:\\Users\\Karl\\Zotero\\storage\\MQJHBMP2\\1456074.html}
}

@article{lehmanSoftwareEvolutionBackground2003,
  title = {Software Evolutionâ{{Background}}, Theory, Practice},
  shorttitle = {Software {{Evolution}}},
  author = {Lehman, Meir M. and Ramil, Juan F.},
  date = {2003-10-17},
  journaltitle = {Information Processing Letters},
  shortjournal = {Information Processing Letters},
  series = {To Honour {{Professor W}}.{{M}}. {{Turski}}'s {{Contribution}} to {{Computing Science}} on the {{Occasion}} of His 65th {{Birthday}}},
  volume = {88},
  number = {1},
  pages = {33--44},
  issn = {0020-0190},
  doi = {10.1016/S0020-0190(03)00382-X},
  url = {https://www.sciencedirect.com/science/article/pii/S002001900300382X},
  urldate = {2025-03-03},
  abstract = {This paper opens with a brief summary of some 30 years of study of the software evolution phenomenon. The results of those studies include the SPE program classification, a principle of software uncertainty and laws of E-type software evolution. The laws were termed so because they encapsulate phenomena largely independent of the people, the organisations and the domains involved in the evolution of the E-type systems studied. Recent studies have refined earlier conclusions, yielded practical guidelines for software evolution management and provide a basis for the formation of a theory of software evolution. Given the volume of published material and the extent of recent discussions on the topic (see, e.g., [Proc. ICSM, Montreal, 2002, p.~66]), this paper is restricted to an overview that exposes the significance of the evolution phenomenon and its study to the wider community, providing a basis for the future and, in particular, development of a theory of software evolution.},
  keywords = {Assumptions,Best practice,Laws of software evolution,Maintenance,Safety/security in digital systems,Software design and implementation,Software engineering,Software evolution,Software process,Software uncertainty principle,Theory of software evolution},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\J6NDYHTM\\Lehman und Ramil - 2003 - Software evolutionâBackground, theory, practice.pdf;C\:\\Users\\Karl\\Zotero\\storage\\WG5EDLXI\\S002001900300382X.html}
}

@inproceedings{leiteTechnicalDebtManagement2024,
  title = {Technical {{Debt Management}} in {{Agile Software Development}}: {{A Systematic Mapping Study}}},
  shorttitle = {Technical {{Debt Management}} in {{Agile Software Development}}},
  booktitle = {Proceedings of the {{XXIII Brazilian Symposium}} on {{Software Quality}}},
  author = {Leite, Gilberto de Sousa and Vieira, Ricardo EugÃªnio Porto and Cerqueira, Lidiany and Maciel, Rita Suzana Pitangueira and Freire, SÃ¡vio and MendonÃ§a, Manoel},
  date = {2024-12-21},
  series = {{{SBQS}} '24},
  pages = {309--320},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/3701625.3701669},
  url = {https://dl.acm.org/doi/10.1145/3701625.3701669},
  urldate = {2025-03-17},
  abstract = {Context: Agile methodologies use continuous delivery and adaptability to develop software that meets the needs of its users. However, such methods are prone to accumulate technical debt (TD). Agile teams must balance the benefits and risks of incurring debt by managing TD items. Knowing how TD management is conducted in agile software teams can help agile practitioners increase their ability to handle TD items. Aims: To investigate, based on the state of the art, how agile software teams have managed existing TD items in their projects. Method: We carried out a systematic mapping study covering 39 articles from 2010 to 2023. Results: Among the agile methodologies, Scrum was the most used for TD management. Regarding practices, agile teams employ mostly user stories and sprint backlogs to identify TD items. Sprints and sprint backlogs are used to monitor debt, while refactoring is applied to prevent and repay TD items. Conclusion: This study maps current knowledge on TD management in agile methodologies, serving as a starting point for new investigations in the area.},
  isbn = {979-8-4007-1777-2},
  file = {C:\Users\Karl\Zotero\storage\P8NWTGK5\Leite et al. - 2024 - Technical Debt Management in Agile Software Development A Systematic Mapping Study.pdf}
}

@article{liPDFSystematicMapping2024,
  title = {({{PDF}}) {{A Systematic Mapping Study}} on {{Technical Debt}} and {{Its Management}}},
  author = {Li, Zengyang and Avgeriou, Paris and Liang, Peng},
  date = {2024-10-22},
  journaltitle = {ResearchGate},
  doi = {10.1016/j.jss.2014.12.027},
  url = {https://www.researchgate.net/publication/269396520_A_Systematic_Mapping_Study_on_Technical_Debt_and_Its_Management},
  urldate = {2025-03-12},
  abstract = {PDF | Context: Technical debt (TD) is a metaphor reflecting technical compromises that can yield short-term benefit but may hurt the long-term health of... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\K9CXXI3M\269396520_A_Systematic_Mapping_Study_on_Technical_Debt_and_Its_Management.html}
}

@article{liSystematicMappingStudy2015,
  title = {A Systematic Mapping Study on Technical Debt and Its Management},
  shorttitle = {Mapping of {{Technical Debt}}},
  author = {Li, Zengyang and Avgeriou, Paris and Liang, Peng},
  date = {2015-03-01},
  journaltitle = {Journal of Systems and Software},
  shortjournal = {Journal of Systems and Software},
  volume = {101},
  pages = {193--220},
  issn = {0164-1212},
  doi = {10.1016/j.jss.2014.12.027},
  url = {https://www.sciencedirect.com/science/article/pii/S0164121214002854},
  urldate = {2025-03-12},
  abstract = {Context Technical debt (TD) is a metaphor reflecting technical compromises that can yield short-term benefit but may hurt the long-term health of a software system. Objective This work aims at collecting studies on TD and TD management (TDM), and making a classification and thematic analysis on these studies, to obtain a comprehensive understanding on the TD concept and an overview on the current state of research on TDM. Method A systematic mapping study was performed to identify and analyze research on TD and its management, covering publications between 1992 and 2013. Results Ninety-four studies were finally selected. TD was classified into 10 types, 8 TDM activities were identified, and 29 tools for TDM were collected. Conclusions The term âdebtâ has been used in different ways by different people, which leads to ambiguous interpretation of the term. Code-related TD and its management have gained the most attention. There is a need for more empirical studies with high-quality evidence on the whole TDM process and on the application of specific TDM approaches in industrial settings. Moreover, dedicated TDM tools are needed for managing various types of TD in the whole TDM process.},
  keywords = {Systematic mapping study,Technical debt,Technical debt management},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\G8LWYHQE\\Li et al. - 2015 - A systematic mapping study on technical debt and its management.pdf;C\:\\Users\\Karl\\Zotero\\storage\\7S5XI82U\\S0164121214002854.html}
}

@article{liUnderstandingSoftwareArchitecture2022,
  title = {Understanding {{Software Architecture Erosion}}: {{A Systematic Mapping Study}}},
  shorttitle = {Understanding {{Software Architecture Erosion}}},
  author = {Li, Ruiyin and Liang, Peng and Soliman, Mohamed and Avgeriou, Paris},
  date = {2022-03},
  journaltitle = {Journal of Software: Evolution and Process},
  shortjournal = {J Software Evolu Process},
  volume = {34},
  number = {3},
  eprint = {2112.10934},
  eprinttype = {arXiv},
  eprintclass = {cs},
  pages = {e2423},
  issn = {2047-7473, 2047-7481},
  doi = {10.1002/smr.2423},
  url = {http://arxiv.org/abs/2112.10934},
  urldate = {2025-03-24},
  abstract = {Architecture erosion (AEr) can adversely affect software development and has received significant attention in the last decade. However, there is an absence of a comprehensive understanding of the state of research about the reasons and consequences of AEr, and the countermeasures to address AEr. This work aims at systematically investigating, identifying, and analyzing the reasons, consequences, and ways of detecting and handling AEr. With 73 studies included, the main results are as follows: (1) AEr manifests not only through architectural violations and structural issues but also causing problems in software quality and during software evolution; (2) non-technical reasons that cause AEr should receive the same attention as technical reasons, and practitioners should raise awareness of the grave consequences of AEr, thereby taking actions to tackle AEr-related issues; (3) a spectrum of approaches, tools, and measures has been proposed and employed to detect and tackle AEr; and (4) three categories of difficulties and five categories of lessons learned on tackling AEr were identified. The results can provide researchers a comprehensive understanding of AEr and help practitioners handle AEr and improve the sustainability of their architecture. More empirical studies are required to investigate the practices of detecting and addressing AEr in industrial settings.},
  keywords = {Computer Science - Software Engineering},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\7BZUPN25\\Li et al. - 2022 - Understanding Software Architecture Erosion A Systematic Mapping Study.pdf;C\:\\Users\\Karl\\Zotero\\storage\\TLBA2WXQ\\2112.html}
}

@online{ManagingTechnicalDebt,
  title = {Managing {{Technical Debt}} -- {{Reducing Friction}} in {{Software Development}} | {{Request PDF}}},
  url = {https://www.researchgate.net/publication/331454554_Managing_Technical_Debt_--_Reducing_Friction_in_Software_Development},
  urldate = {2025-03-17},
  abstract = {Request PDF | Managing Technical Debt -- Reducing Friction in Software Development | As software systems mature, earlier design or code decisions made in the context of budget or schedule constraints increasingly impede evolution... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  organization = {ResearchGate},
  file = {C:\Users\Karl\Zotero\storage\BYX996JB\331454554_Managing_Technical_Debt_--_Reducing_Friction_in_Software_Development.html}
}

@article{maxwellSoftwareDevelopmentProductivity1996,
  title = {Software Development Productivity of {{European}} Space, Military, and Industrial Applications},
  author = {Maxwell, K.D. and Van Wassenhove, L. and Dutta, S.},
  date = {1996-10},
  journaltitle = {IEEE Transactions on Software Engineering},
  shortjournal = {IIEEE Trans. Software Eng.},
  volume = {22},
  number = {10},
  pages = {706--718},
  issn = {00985589},
  doi = {10.1109/32.544349},
  url = {http://ieeexplore.ieee.org/document/544349/},
  urldate = {2025-02-07},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\QCJUPMHH\Maxwell et al. - 1996 - Software development productivity of European space, military, and industrial applications.pdf}
}

@report{mcconnellManagingTechnicalDebt2017,
  title = {Managing {{Technical Debt}}},
  shorttitle = {Managing {{Technical Debt}}},
  author = {McConnell, Steve},
  date = {2017-02-24T05:54:41+00:00},
  url = {https://www.construx.com/resources/whitepaper-managing-technical-debt/},
  urldate = {2025-03-10},
  abstract = {In this white paper, Steve McConnell explains the types of technical debt, when organizations should take on debt, and best practices for dealing with it.},
  langid = {american},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\EI24VIAR\\2017 - Managing Technical Debt  Construx.pdf;C\:\\Users\\Karl\\Zotero\\storage\\XX6XEK6J\\whitepaper-managing-technical-debt.html}
}

@article{mcintoshEmpiricalStudyImpact2016,
  title = {An Empirical Study of the Impact of Modern Code Review Practices on Software Quality},
  shorttitle = {Impact {{Code Review}}},
  author = {Mcintosh, Shane and Kamei, Yasutaka and Adams, Bram and Hassan, Ahmed E.},
  date = {2016-10-01},
  journaltitle = {Empirical Software Engineering},
  volume = {21},
  number = {5},
  pages = {2146--2189},
  issn = {1382-3256},
  doi = {10.1007/s10664-015-9381-9},
  url = {https://doi.org/10.1007/s10664-015-9381-9},
  urldate = {2025-03-21},
  abstract = {Software code review, i.e., the practice of having other team members critique changes to a software system, is a well-established best practice in both open source and proprietary software domains. Prior work has shown that formal code inspections tend to improve the quality of delivered software. However, the formal code inspection process mandates strict review criteria (e.g., in-person meetings and reviewer checklists) to ensure a base level of review quality, while the modern, lightweight code reviewing process does not. Although recent work explores the modern code review process, little is known about the relationship between modern code review practices and long-term software quality. Hence, in this paper, we study the relationship between post-release defects (a popular proxy for long-term software quality) and: (1) code review coverage, i.e., the proportion of changes that have been code reviewed, (2) code review participation, i.e., the degree of reviewer involvement in the code review process, and (3) code reviewer expertise, i.e., the level of domain-specific expertise of the code reviewers. Through a case study of the Qt, VTK, and ITK projects, we find that code review coverage, participation, and expertise share a significant link with software quality. Hence, our results empirically confirm the intuition that poorly-reviewed code has a negative impact on software quality in large systems using modern reviewing tools.},
  file = {C:\Users\Karl\Zotero\storage\M8T87YPK\Mcintosh et al. - 2016 - An empirical study of the impact of modern code review practices on software quality.pdf}
}

@inproceedings{moserCaseStudyImpact2008,
  title = {A {{Case Study}} on the {{Impact}} of {{Refactoring}} on {{Quality}} and {{Productivity}} in an {{Agile Team}}},
  shorttitle = {Case {{Study Refactoring}}},
  booktitle = {Balancing {{Agility}} and {{Formalism}} in {{Software Engineering}}},
  author = {Moser, Raimund and Abrahamsson, Pekka and Pedrycz, Witold and Sillitti, Alberto and Succi, Giancarlo},
  editor = {Meyer, Bertrand and Nawrocki, Jerzy R. and Walter, Bartosz},
  date = {2008},
  volume = {5082},
  pages = {252--266},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-85279-7_20},
  url = {http://link.springer.com/10.1007/978-3-540-85279-7_20},
  urldate = {2025-03-17},
  abstract = {Refactoring is a hot and controversial issue. Supporters claim that it helps increasing the quality of the code, making it easier to understand, modify and maintain. Moreover, there are also claims that refactoring yields higher development productivity --- however, there is only limited empirical evidence of such assumption. A case study has been conducted to assess the impact of refactoring in a close-to industrial environment. Results indicate that refactoring not only increases aspects of software quality, but also improves productivity. Our findings are applicable to small teams working in similar, highly volatile domains (ours is application development for mobile devices). However, additional research is needed to ensure that this is indeed true and to generalize it to other contexts.},
  isbn = {978-3-540-85278-0 978-3-540-85279-7},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\FNQAMITR\Moser et al. - 2008 - A Case Study on the Impact of Refactoring on Quality and Productivity in an Agile Team.pdf}
}

@inproceedings{murilloTechnicalDebtMeasurement2021,
  title = {Technical {{Debt Measurement}} during {{Software Development}} Using {{Sonarqube}}: {{Literature Review}} and a {{Case Study}}},
  shorttitle = {Technical {{Debt Measurement}} during {{Software Development}} Using {{Sonarqube}}},
  booktitle = {2021 {{IEEE V Jornadas Costarricenses}} de {{InvestigaciÃ³n}} En {{ComputaciÃ³n}} e {{InformÃ¡tica}} ({{JoCICI}})},
  author = {Murillo, MarÃ­a Isabel and Jenkins, Marcelo},
  date = {2021-10},
  pages = {1--6},
  doi = {10.1109/JoCICI54528.2021.9794341},
  url = {https://ieeexplore.ieee.org/document/9794341},
  urldate = {2025-03-19},
  abstract = {Technical debt comprises the construction of poor software during the development process, potentially leading to several problems for organizations. For this reason, it is convenient to measure it and apply timely strategies to prevent unwanted consequences. Technical debt identification and measurement may be supported by static analysis tools, such as Sonarqube. This paper aims to analyze, evaluate, and apply the technical debt metrics proposed by Sonarqube. We present a literature review about technical debt measurement with this tool and describe the results of a case study. Based on the literature review and the case study results, we analyze the advantages, disadvantages, and limitations of using Sonarqube for technical debt measurement. We conclude that there are several threats to the validity on the proposed metrics, which may lead to inaccurate results. However, Sonarqube can still support technical debt management during the software development process.},
  eventtitle = {2021 {{IEEE V Jornadas Costarricenses}} de {{InvestigaciÃ³n}} En {{ComputaciÃ³n}} e {{InformÃ¡tica}} ({{JoCICI}})},
  keywords = {Bibliographies,Metrics,Organizations,Software,Software measurement,Software Quality,Sonarqube,Static analysis,Technical Debt},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\PAF8YEEN\\Murillo and Jenkins - 2021 - Technical Debt Measurement during Software Development using Sonarqube Literature Review and a Case.pdf;C\:\\Users\\Karl\\Zotero\\storage\\SURR5NVN\\9794341.html}
}

@inproceedings{murphySoftwareEngineeringResearch2021,
  title = {Is Software Engineering Research Addressing Software Engineering Problems? (Keynote)},
  shorttitle = {Is Software Engineering Research Addressing Software Engineering Problems?},
  booktitle = {Proceedings of the 35th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}}},
  author = {Murphy, Gail C.},
  date = {2021-01-27},
  series = {{{ASE}} '20},
  pages = {4--5},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/3324884.3417103},
  url = {https://dl.acm.org/doi/10.1145/3324884.3417103},
  urldate = {2025-02-19},
  abstract = {Brian Randell described software engineering as "the multi-person development of multi-version programs". David Parnas expressed that this "pithy phrase implies everything that differentiates software engineering from other programming" (Parnas, 2011). How does current software engineering research compare against this definition? Is there too much focus currently on research into problems and techniques more associated with programming than software engineering? Are there opportunities to use Randell's description of software engineering to guide the community to new research directions? In this extended abstract, I motivate the keynote, which explores these questions and discusses how a consideration of the development streams used by multiple individuals to produce multiple versions of software opens up new avenues for impactful software engineering research.},
  isbn = {978-1-4503-6768-4},
  file = {C:\Users\Karl\Zotero\storage\QX3KG7S7\Murphy - 2021 - Is software engineering research addressing software engineering problems (keynote).pdf}
}

@inproceedings{nordSearchMetricManaging2012,
  title = {In {{Search}} of a {{Metric}} for {{Managing Architectural Technical Debt}}},
  shorttitle = {Managing {{Architectural Technical Debt}}},
  booktitle = {2012 {{Joint Working IEEE}}/{{IFIP Conference}} on {{Software Architecture}} and {{European Conference}} on {{Software Architecture}}},
  author = {Nord, Robert L. and Ozkaya, Ipek and Kruchten, Philippe and Gonzalez-Rojas, Marco},
  date = {2012-08},
  pages = {91--100},
  doi = {10.1109/WICSA-ECSA.212.17},
  url = {https://ieeexplore.ieee.org/document/6337765},
  urldate = {2025-03-24},
  abstract = {Practices designed to expedite the delivery of stakeholder value can paradoxically lead to unexpected rework costs that ultimately degrade the flow of value over time. This is especially observable when features are developed based on immediate value, while dependencies that may slow down future development efforts are neglected. The technical debt metaphor conceptualizes this tradeoff between short-term and long-term value: taking shortcuts to optimize the delivery of features in the short term incurs debt, analogous to financial debt, that must be paid off later to optimize long-term success. In this paper, we describe taking an architecture-focused and measurement-based approach to develop a metric that assists in strategically managing technical debt. Such an approach can be used to optimize the cost of development over time while continuing to deliver value to the customer. We demonstrate our approach by describing its application to an ongoing system development effort.},
  eventtitle = {2012 {{Joint Working IEEE}}/{{IFIP Conference}} on {{Software Architecture}} and {{European Conference}} on {{Software Architecture}}},
  keywords = {Computer architecture,cost of rework,Data models,Educational institutions,Maintenance engineering,Measurement,Organizations,Software,software architecture,software economics,technical debt,total cost of ownership},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\P3SH44V5\\Nord et al. - 2012 - In Search of a Metric for Managing Architectural Technical Debt.pdf;C\:\\Users\\Karl\\Zotero\\storage\\CXZ5NX5X\\6337765.html}
}

@incollection{nrc2015defense,
  title = {Defense and Commercial System Development: A Comparison},
  shorttitle = {Comparison {{Defense Commerical}}},
  booktitle = {Reliability Growth: {{Enhancing}} Defense System Reliability},
  author = {{National Research Council}},
  date = {2015},
  pages = {19--33},
  publisher = {The National Academies Press},
  location = {Washington, DC},
  url = {https://nap.nationalacademies.org/read/18987/chapter/4},
  urldate = {2025-03-25},
  isbn = {978-0-309-31474-9},
  file = {C:\Users\Karl\Zotero\storage\3WV66H93\National Research Council - 2015 - Defense and commercial system development a comparison.pdf}
}

@article{oakleyDEFENSESOFTWAREACQUISITIONS2023,
  title = {{{DEFENSE SOFTWARE ACQUISITIONS}}: {{Changes}} to {{Requirements}}, {{Oversight}}, and {{Tools Needed}} for {{Weapon Programs}}.},
  shorttitle = {{{DEFENSE SOFTWARE ACQUISITIONS}}},
  author = {Oakley, Shelby S.},
  date = {2023-07-20},
  journaltitle = {GAO Reports},
  shortjournal = {GAO Reports},
  pages = {1--37},
  publisher = {United States Government Accountability Office},
  url = {https://research.ebsco.com/linkprocessor/plink?id=14b2fe6f-e431-3178-ac38-b7c2d4072e4e},
  urldate = {2025-02-03},
  abstract = {The article focuses on the Government Accountability Office's (GAO) assessment of the Department of Defense's (DOD) software modernization efforts. The three topics covered are the establishment of policy and guidance for Agile software development in weapon programs, providing direction for overseeing Agile software development, and enabling program adoption of modern engineering tools for Agile.},
  langid = {english},
  keywords = {AGILE software development,ENGINEERING equipment,MILITARY weapons,Other Professional Equipment and Supplies Merchant Wholesalers,UNITED States. Dept. of Defense,UNITED States. Government Accountability Office},
  file = {C:\Users\Karl\Zotero\storage\R7WZ45X8\Oakley - 2023 - DEFENSE SOFTWARE ACQUISITIONS Changes to Requirements, Oversight, and Tools Needed for Weapon Progr.pdf}
}

@online{OntologyTechnicalDebt,
  title = {Ontology for {{Technical Debt}} in {{Systems Engineering}} | {{IEEE Journals}} \& {{Magazine}} | {{IEEE Xplore}}},
  url = {https://ieeexplore.ieee.org/document/10254240},
  urldate = {2025-02-17},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\SD8SZ5JV\\Kleinwaks et al. - 2023 - Ontology for Technical Debt in Systems Engineering.pdf;C\:\\Users\\Karl\\Zotero\\storage\\VDP97N42\\10254240.html}
}

@article{PDFEmpiricalStudy2024,
  title = {({{PDF}}) {{An}} Empirical Study of the Impact of Modern Code Review Practices on Software Quality},
  date = {2024-10-22},
  journaltitle = {ResearchGate},
  doi = {10.1007/s10664-015-9381-9},
  url = {https://www.researchgate.net/publication/276162927_An_empirical_study_of_the_impact_of_modern_code_review_practices_on_software_quality},
  urldate = {2025-03-21},
  abstract = {PDF | Software code review, i.e., the practice of having other team members critique changes to a software system, is a well-established best practice... | Find, read and cite all the research you need on ResearchGate},
  langid = {english}
}

@article{PDFNoSilver2024,
  title = {({{PDF}}) {{No Silver Bullet Essence}} and {{Accidents}} of {{Software Engineering}}},
  date = {2024-10-22},
  journaltitle = {ResearchGate},
  doi = {10.1109/MC.1987.1663532},
  url = {https://www.researchgate.net/publication/220477127_No_Silver_Bullet_Essence_and_Accidents_of_Software_Engineering},
  urldate = {2025-02-19},
  abstract = {PDF | First Page of the Article | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\WW7DYUC4\220477127_No_Silver_Bullet_Essence_and_Accidents_of_Software_Engineering.html}
}

@article{PDFNoSilver2024a,
  title = {({{PDF}}) {{No Silver Bullet Essence}} and {{Accidents}} of {{Software Engineering}}},
  date = {2024-10-22},
  journaltitle = {ResearchGate},
  doi = {10.1109/MC.1987.1663532},
  url = {https://www.researchgate.net/publication/220477127_No_Silver_Bullet_Essence_and_Accidents_of_Software_Engineering},
  urldate = {2025-02-19},
  abstract = {PDF | First Page of the Article | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\YSWPFCDC\220477127_No_Silver_Bullet_Essence_and_Accidents_of_Software_Engineering.html}
}

@online{PDFQualityGates2025,
  title = {({{PDF}}) {{Quality Gates}} in {{Software Development}}: {{Concepts}}, {{Definition}} and {{Tools}}},
  shorttitle = {({{PDF}}) {{Quality Gates}} in {{Software Development}}},
  date = {2025-01-29},
  url = {https://www.researchgate.net/publication/386363144_Quality_Gates_in_Software_Development_Concepts_Definition_and_Tools},
  urldate = {2025-03-21},
  abstract = {PDF | In the domain of software development, it is crucial to maintain high quality in order to meet the increasing demands of users and the rapid pace... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  organization = {ResearchGate},
  file = {C:\Users\Karl\Zotero\storage\WCKC5NFK\386363144_Quality_Gates_in_Software_Development_Concepts_Definition_and_Tools.html}
}

@article{PDFSystematicLiterature2025,
  title = {({{PDF}}) {{A}} Systematic Literature Review of Literature Reviews in Software Testing},
  date = {2025-02-18},
  journaltitle = {ResearchGate},
  doi = {10.1016/j.infsof.2016.09.002},
  url = {https://www.researchgate.net/publication/308092761_A_systematic_literature_review_of_literature_reviews_in_software_testing},
  urldate = {2025-02-19},
  abstract = {PDF | Context: Any newcomer or industrial practitioner is likely to experience difficulties in digesting large volumes of knowledge in software testing.... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\7LDEIU8J\\2025 - (PDF) A systematic literature review of literature reviews in software testing.pdf;C\:\\Users\\Karl\\Zotero\\storage\\RJGIBXMQ\\308092761_A_systematic_literature_review_of_literature_reviews_in_software_testing.html}
}

@article{perryFoundationsStudySoftware1992,
  title = {Foundations for the Study of Software Architecture},
  author = {Perry, Dewayne E. and Wolf, Alexander L.},
  date = {1992-10-01},
  journaltitle = {SIGSOFT Softw. Eng. Notes},
  volume = {17},
  number = {4},
  pages = {40--52},
  issn = {0163-5948},
  doi = {10.1145/141874.141884},
  url = {https://dl.acm.org/doi/10.1145/141874.141884},
  urldate = {2025-03-24},
  abstract = {The purpose of this paper is to build the foundation for software architecture. We first develop an intuition for software architecture by appealing to several well-established architectural disciplines. On the basis of this intuition, we present a model of software architecture that consists of three components: elements, form, and rationale. Elements are either processing, data, or connecting elements. Form is defined in terms of the properties of, and the relationships among, the elements --- that is, the constraints on the elements. The rationale provides the underlying basis for the architecture in terms of the system constraints, which most often derive from the system requirements. We discuss the components of the model in the context of both architectures and architectural styles and present an extended example to illustrate some important architecture and style considerations. We conclude by presenting some of the benefits of our approach to software architecture, summarizing our contributions, and relating our approach to other current work.},
  file = {C:\Users\Karl\Zotero\storage\9MEFKT4D\Perry and Wolf - 1992 - Foundations for the study of software architecture.pdf}
}

@inproceedings{potdarExploratoryStudySelfAdmitted2014,
  title = {An {{Exploratory Study}} on {{Self-Admitted Technical Debt}}},
  shorttitle = {Self-{{Admitted Debt}}},
  booktitle = {Proceedings of the 2014 {{IEEE International Conference}} on {{Software Maintenance}} and {{Evolution}}},
  author = {Potdar, Aniket and Shihab, Emad},
  date = {2014-09-29},
  series = {{{ICSME}} '14},
  pages = {91--100},
  publisher = {IEEE Computer Society},
  location = {USA},
  doi = {10.1109/ICSME.2014.31},
  url = {https://doi.org/10.1109/ICSME.2014.31},
  urldate = {2025-03-12},
  abstract = {Throughout a software development life cycle, developers knowingly commit code that is either incomplete, requires rework, produces errors, or is a temporary workaround. Such incomplete or temporary workarounds are commonly referred to as 'technical debt'. Our experience indicates that self-admitted technical debt is common in software projects and may negatively impact software maintenance, however, to date very little is known about them. Therefore, in this paper, we use source-code comments in four large open source software projects-Eclipse, Chromium OS, Apache HTTP Server, and ArgoUML to identify self-admitted technical debt. Using the identified technical debt, we study 1) the amount of self-admitted technical debt found in these projects, 2) why this self-admitted technical debt was introduced into the software projects and 3) how likely is the self-admitted technical debt to be removed after their introduction. We find that the amount of self-admitted technical debt exists in 2.4\% -- 31\% of the files. Furthermore, we find that developers with higher experience tend to introduce most of the self-admitted technical debt and that time pressures and complexity of the code do not correlate with the amount of self-admitted technical debt. Lastly, although self-admitted technical debt is meant to be addressed or removed in the future, only between 26.3\% -- 63.5\% of self-admitted technical debt gets removed from projects after introduction.},
  isbn = {978-1-4799-6146-7},
  file = {C:\Users\Karl\Zotero\storage\7IIV6WWD\Potdar und Shihab - 2014 - An Exploratory Study on Self-Admitted Technical Debt.pdf}
}

@online{ProjektsteuerungMitVModell,
  title = {Projektsteuerung mit V-ModellÂ® XT},
  url = {http://www.itzbund.de/DE/digitalemission/trendstechnologien/projektsteuerung/projektsteuerung.html?nn=179356},
  urldate = {2025-03-26},
  abstract = {Bei der Entwicklung von IT-Systemen hat sich in Deutschland das V-ModellÂ® XT als Vorgehensmodell vielfach bewÃ¤hrt. Die Bundesverwaltung nutzt mit UnterstÃ¼tzung des ITZBund auch eigene Varianten des V-ModellsÂ® XT, um Projekte passend zu ihren BedÃ¼rfnissen umzusetzen.},
  langid = {ngerman},
  organization = {ITZBund}
}

@article{ramacPrevalenceCommonCauses2021,
  title = {Prevalence, {{Common Causes}} and {{Effects}} of {{Technical Debt}}: {{Results}} from a {{Family}} of {{Surveys}} with the {{IT Industry}}},
  shorttitle = {Prevalence, {{Common Causes}} and {{Effects}} of {{Technical Debt}}},
  author = {RamaÄ, Robert and MandiÄ, Vladimir and TauÅ¡an, NebojÅ¡a and Rios, Nicolli and Freire, SÃ¡vio and PÃ©rez, Boris and Castellanos, Camilo and Correal, DarÃ­o and Pacheco, Alexia and Lopez, Gustavo and Izurieta, Clemente and Seaman, Carolyn and Spinola, Rodrigo},
  date = {2021-09},
  journaltitle = {Journal of Systems and Software},
  shortjournal = {Journal of Systems and Software},
  volume = {184},
  eprint = {2109.13771},
  eprinttype = {arXiv},
  eprintclass = {cs},
  issn = {01641212},
  doi = {10.1016/j.jss.2021.111114},
  url = {http://arxiv.org/abs/2109.13771},
  urldate = {2025-03-21},
  abstract = {The technical debt (TD) metaphor describes actions made during various stages of software development that lead to a more costly future regarding system maintenance and evolution. According to recent studies, on average 25\% of development effort is spent, i.e. wasted, on TD caused issues in software development organizations. However, further research is needed to investigate the relations between various software development activities and TD. The objective of this study is twofold. First, to get empirical insight on the understanding and the use of the TD concept in the IT industry. Second, to contribute towards precise conceptualization of the TD concept through analysis of causes and effects. In order to address the research objective a family of surveys was designed as a part of an international initiative that congregates researchers from 12 countries -- InsighTD. At country level, national teams ran survey replications with industry practitioners from the respective countries. In total 653 valid responses were collected from 6 countries. Regarding the prevalence of the TD concept 22\% of practitioners have only theoretical knowledge about it, and 47\% have some practical experiences with TD identification or management. Further analysis indicated that senior practitioners who work in larger organizations, larger teams, and on larger systems are more likely to be experienced with TD management. Time pressure or deadline was the single most cited cause of TD. Regarding the effects of TD: delivery delay, low maintainability, and rework were the most cited. InsighTD is the first family of surveys on technical debt in software engineering. It provided a methodological framework that allowed multiple replication teams to conduct research activities and to contribute to a single dataset. Future work will focus on more specific aspects of TD management.},
  keywords = {Computer Science - Software Engineering},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\5KZ3TZKZ\\RamaÄ et al. - 2022 - Prevalence, Common Causes and Effects of Technical Debt Results from a Family of Surveys with the I.pdf;C\:\\Users\\Karl\\Zotero\\storage\\3JR86DNG\\2109.html}
}

@online{RefactoringImprovingDesign,
  title = {Refactoring: {{Improving}} the {{Design}} of {{Existing Code}}[{{Book}}]},
  shorttitle = {Refactoring},
  url = {https://www.oreilly.com/library/view/refactoring-improving-the/9780134757681/},
  urldate = {2025-03-13},
  abstract = {Fully Revised and UpdatedâIncludes New Refactorings and Code Examples âAny fool can write code that a computer can understand. Good programmers write code that humans can understand.â âM. Fowler (1999) â¦ - Selection from Refactoring: Improving the Design of Existing Code [Book]},
  isbn = {9780134757681},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\TI63VCWN\9780134757681.html}
}

@book{RefactoringImprovingDesign1999,
  title = {Refactoring: Improving the Design of Existing Code},
  shorttitle = {Refactoring},
  date = {1999-06},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  location = {USA},
  abstract = {As the application of object technology--particularly the Java programming language--has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, "non-optimal" applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as "refactoring," these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Code, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process.With proper training a skilled system designer can take a bad design and rework it into well-designed, robust code. In this book, Martin Fowler shows you where opportunities for refactoring typically can be found, and how to go about reworking a bad design into a good one. Each refactoring step is simple--seemingly too simple to be worth doing. Refactoring may involve moving a field from one class to another, or pulling some code out of a method to turn it into its own method, or even pushing some code up or down a hierarchy. While these individual steps may seem elementary, the cumulative effect of such small changes can radically improve the design. Refactoring is a proven way to prevent software decay.In addition to discussing the various techniques of refactoring, the author provides a detailed catalog of more than seventy proven refactorings with helpful pointers that teach you when to apply them; step-by-step instructions for applying each refactoring; and an example illustrating how the refactoring works. The illustrative examples are written in Java, but the ideas are applicable to any object-oriented programming language. 0201485672B04062001},
  isbn = {978-0-201-48567-7},
  pagetotal = {464},
  file = {C:\Users\Karl\Zotero\storage\P7FVIZ3U\Fowler et al. - Refactoring - Improving the Design of Existing Code.pdf}
}

@article{reimanisStudyBehavioralDecay2024,
  title = {A Study of Behavioral Decay in Design Patterns.},
  author = {Reimanis, Derek and Izurieta, Clemente},
  date = {2024-07-01},
  journaltitle = {Journal of Software: Evolution \& Process},
  shortjournal = {Journal of Software: Evolution \& Process},
  volume = {36},
  number = {7},
  pages = {1--20},
  publisher = {Wiley-Blackwell},
  issn = {2047-7473},
  doi = {10.1002/smr.2638},
  url = {https://research.ebsco.com/linkprocessor/plink?id=8092673b-6833-3c7b-9acb-f563073137e1},
  urldate = {2025-02-03},
  abstract = {Design patterns represent a means of communicating reusable solutions to common problems, provided they are implemented and maintained correctly. However, many design pattern instances erode as they age, sacrificing qualities they once provided. Identifying such instances of pattern decay is valuable because it allows for proactive attempts to extend the longevity and quality attributes of pattern components. Apart from structural decay, design patterns can exhibit symptoms of behavioral decay. We utilized a taxonomy that characterizes these negative behaviors and designed a case study wherein we measured structural and behavioral decay, hereafter referred to as pattern grime, as well as pattern quality and size, across pattern evolutions. We evaluated the relationships between structural and behavioral grime and found statistically significant cases of strong correlations between specific types of structural and behavioral grime. Furthermore, we extended the QATCH operational software quality model to incorporate design pattern evolution metrics and measured and correlated software quality to the presence of behavioral grime in software systems. Our results suggest a strong inverse relationship between software quality and behavioral grime.},
  langid = {english},
  keywords = {COMPUTER software quality control,SOFTWARE architecture,SOFTWARE engineering,SOFTWARE maintenance,SOFTWARE measurement,SYSTEMS software},
  file = {C:\Users\Karl\Zotero\storage\FVY965RL\Reimanis und Izurieta - 2024 - A study of behavioral decay in design patterns..pdf}
}

@book{ReliabilityGrowthEnhancing,
  title = {Reliability {{Growth}}: {{Enhancing Defense System Reliability}}},
  shorttitle = {Reliability {{Growth}}},
  doi = {10.17226/18987},
  url = {https://nap.nationalacademies.org/read/18987/chapter/4},
  urldate = {2025-03-25},
  abstract = {Read chapter 2 Defense and Commercial System Development: A Comparison: A high percentage of defense systems fail to meet their reliability requirements. ...},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\QW5PV3CR\4.html}
}

@article{rinta-kahilaGETTINGTRAPPEDTECHNICAL2023,
  title = {{{GETTING TRAPPED IN TECHNICAL DEBT}}: {{SOCIOTEGETTING TRAPPED IN TECHNICAL DEBT}}: {{SOCIOTECHNICAL ANALYSIS OF A LEGACY SYSTEM}}â{{S REPLACEMENT1CHNICAL ANALYSIS OF A LEGACY SYSTEM}}â{{S REPLACEMENT}}.},
  shorttitle = {{{GETTING TRAPPED IN TECHNICAL DEBT}}},
  author = {Rinta-Kahila, Tapani and Penttinen, Esko and Lyytinen, Kalle},
  date = {2023-03-01},
  journaltitle = {MIS Quarterly},
  shortjournal = {MIS Quarterly},
  volume = {47},
  number = {1},
  pages = {1--31},
  publisher = {MIS Quarterly},
  issn = {0276-7783},
  doi = {10.25300/MISQ/2022/16711},
  url = {https://research.ebsco.com/linkprocessor/plink?id=f5da5c29-63aa-38b2-8af9-0cdf2aa009cb},
  urldate = {2025-02-17},
  abstract = {Organizations replace their legacy systems for technical, economic, and operational reasons. Replacement is a risky proposition, as high levels of technical and social inertia make these systems hard to withdraw. Failure to fully replace systems results in complex system architectures involving manifold hidden dependencies that carry technical debt. To understand how a process for replacing a complex legacy system unfolds and accumulates technical debt, we conducted an explanatory case study at a local manufacturing site that had struggled to replace its mission-critical legacy systems as part of the larger global companyâs commercial-off-the-shelf (COTS) system implementation. We approach the replacement as a sociotechnical change and leverage the punctuated sociotechnical information system change model in combination with the design-moves framework to analyze how the site balanced creating digital options, countering social inertia, and managing (architectural) technical debt. The findings generalize to a two-level (local/global) system-dynamics model delineating how replacing a deeply entrenched mission-critical system generates positive and negative feedback loops within and between social and technical changes at local and global levels. The loops, unless addressed, accrue technical debt that hinders legacy system discontinuance and gradually locks the organization into a debtconstrained state. The model helps managers anticipate challenges that accompany replacing highly entrenched systems and formulate effective strategies to address them.},
  langid = {english},
  keywords = {Consumer Lending,CORPORATE debt,CORPORATE finance,DIFFUSION of innovations,INDUSTRIAL management,INNOVATION adoption,ORGANIZATIONAL change,TECHNOLOGY},
  file = {C:\Users\Karl\Zotero\storage\WZVBLUV7\Rinta-Kahila et al. - 2023 - GETTING TRAPPED IN TECHNICAL DEBT SOCIOTEGETTING TRAPPED IN TECHNICAL DEBT SOCIOTECHNICAL ANALYSIS.pdf}
}

@article{riquetDebtStoriesCapturing2024,
  title = {Debt {{Stories}}: {{Capturing Social}} and {{Technical Debt}} in the {{Industry}}},
  shorttitle = {Debt {{Stories}}},
  author = {Riquet, Nicolas and Devroey, Xavier and Vanderose, Benoit},
  date = {2024-04-14},
  journaltitle = {2024 IEEE/ACM International Conference on Technical Debt (TechDebt), Technical Debt (TechDebt), 2024 IEEE/ACM International Conference on, TECHDEBT},
  pages = {40--44},
  publisher = {ACM},
  issn = {979-8-4007-0590-8},
  url = {https://research.ebsco.com/linkprocessor/plink?id=46e1d964-40f7-3440-899a-325125f17064},
  urldate = {2025-02-17},
  abstract = {In todayâs organizations, software is mission-critical. However, the legacy of past decisions can make tasks related to artifacts increasingly inefficient or risky, creating debt. While most researchers and practitioners mainly focus on technical debt, some have investigated its social dimensions, known as social debt. We argue that organizations developing software need to tackle debt holistically, as it is intrinsically a socio-technical issue. In this short paper, we rely on a definition of socio-technical debt based on the existing literature to define Debt Stories: a tool based on the User Story format, that can help capture debt elements directly from the stake-holders involved in software development. A debt story includes information about the role of the stakeholder in the development process, the social or technical context, and the impact of the debt element on the different tasks performed by the stakeholder. We provide a first empirical evaluation of the usage of Debt Stories in an industrial context, demonstrating the relevance of Debt Stories to express and communicate socio-technical debt.CCS CONCEPTSâ¢ Software and its engineering â Agile software development, Software maintenance tools, â¢ Social and professional topics âSoftware maintenance},
  keywords = {Computing and Processing,debt stories,DevOps,empirical software engineering,Industries,Maintenance,Mission critical systems,Organizations,Production,socio-technical debt,Software maintenance}
}

@inproceedings{schwaberSCRUMDevelopmentProcess1997,
  title = {{{SCRUM Development Process}}},
  shorttitle = {{{SCRUM Process}}},
  booktitle = {Business {{Object Design}} and {{Implementation}}},
  author = {Schwaber, Ken},
  editor = {Sutherland, Jeff and Casanave, Cory and Miller, Joaquin and Patel, Philip and Hollowell, Glenn},
  date = {1997},
  pages = {117--134},
  publisher = {Springer London},
  location = {London},
  doi = {10.1007/978-1-4471-0947-1_11},
  url = {http://link.springer.com/10.1007/978-1-4471-0947-1_11},
  urldate = {2025-03-17},
  abstract = {The stated, accepted philosophy for systems development is that the development process is a well understood approach that can be planned, estimated, and successfully completed. This has proven incorrect in practice. SCRUM assumes that the systems development process is an unpredictable, complicated process that can only be roughly described as an overall progression. SCRUM defines the systems development process as a loose set of activities that combines known, workable tools and techniques with the best that a development team can devise to build systems. Since these activities are loose, controls to manage the process and inherent risk are used. SCRUM is an enhancement of the commonly used iterative/incremental object-oriented development cycle.},
  isbn = {978-3-540-76096-2 978-1-4471-0947-1},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\4LNTSAIZ\Schwaber - 1997 - SCRUM Development Process.pdf}
}

@online{SearchMetricManaging2012,
  title = {In {{Search}} of a {{Metric}} for {{Managing Architectural Technical Debt}}},
  date = {2012-08-01},
  url = {https://insights.sei.cmu.edu/library/in-search-of-a-metric-for-managing-architectural-technical-debt/},
  urldate = {2025-03-24},
  abstract = {This paper describes an architecture-focused and measurement-based approach to developing a metric that will assist in strategically managing technical debt.},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\2GHMFERC\in-search-of-a-metric-for-managing-architectural-technical-debt.html}
}

@misc{shyu2017military,
  title = {A Perspective on Military Software Needs},
  shorttitle = {Military {{Software Needs}}},
  author = {Shyu, Heidi},
  date = {2017-03},
  url = {https://resources.sei.cmu.edu/library/asset-view.cfm?assetid=497913},
  urldate = {2025-03-25},
  howpublished = {Presented at the Carnegie Mellon University Software Engineering Institute (SEI) Symposium},
  organization = {Software Engineering Institute, Carnegie Mellon University},
  file = {C:\Users\Karl\Zotero\storage\B95ZQWQW\Shyu - 2017 - A perspective on military software needs.pdf}
}

@inproceedings{silvaEmpiricalInvestigationInfluence2022,
  title = {Empirical Investigation of the Influence of Continuous Integration Bad Practices on Software Quality},
  shorttitle = {{{CI Bad Practices}}},
  booktitle = {Workshop de {{VisualizaÃ§Ã£o}}, {{EvoluÃ§Ã£o}} e {{ManutenÃ§Ã£o}} de {{Software}} ({{VEM}})},
  author = {Silva, Ruben Blenicio Tavares and Bezerra, Carla},
  date = {2022-10-03},
  pages = {51--55},
  publisher = {SBC},
  issn = {0000-0000},
  doi = {10.5753/vem.2022.226816},
  url = {https://sol.sbc.org.br/index.php/vem/article/view/22330},
  urldate = {2025-03-24},
  abstract = {Continuous Integration (CI) is a powerful tool to leverage software development in a safe, reliable, and efficient way. However, in day-to-day of software development, bad habits can arise in working with CI, which can make CI not reach its full potential in projects. These bad habits we call CI bad practices. This paper presented an exploratory study on closed-source projects to investigate how CI bad practices can affect software quality. We observe (1) the impact on the quality internal attributes after the implantation of CI, (2) the evolution of software quality indicators over time, and (3) the bad practices considered most harmful to the software quality by the development teams. Our results mean that projects affected by CI bad practices will not necessarily have their quality impaired. However, this does not mean that quality will be maintained or improved over time. Our analysis of the quality indicators has allowed us to observe that, generally, they have remained stable, and the number of quality issues reported has not decreased considerably either. Finally, the quality indicator most affected by the CI bad practices was maintainability, followed by reliability and security. In addition, the vast majority of the bad practices analyzed were classified as having a medium level of effort for resolution. In this sense, we also classify bad practices according to the level of effort/impact on the quality that can help prioritize their resolution.},
  eventtitle = {Workshop de {{VisualizaÃ§Ã£o}}, {{EvoluÃ§Ã£o}} e {{ManutenÃ§Ã£o}} de {{Software}} ({{VEM}})},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\W6TFE5P7\Silva and Bezerra - 2022 - Empirical investigation of the influence of continuous integration bad practices on software quality.pdf}
}

@online{SoftwareDeteriorationMaintainability,
  title = {Software {{Deterioration And Maintainability}} - {{A Model Proposal}} | {{Request PDF}}},
  url = {https://www.researchgate.net/publication/2540166_Software_Deterioration_And_Maintainability_-_A_Model_Proposal},
  urldate = {2025-03-21},
  abstract = {Request PDF | Software Deterioration And Maintainability - A Model Proposal | In this paper, we connect the notion of software maintainability with the problem of software deterioration. We propose a model that incorporates... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  organization = {ResearchGate},
  file = {C:\Users\Karl\Zotero\storage\57GAJUG2\2540166_Software_Deterioration_And_Maintainability_-_A_Model_Proposal.html}
}

@online{sonarqubeUnderstandingMeasuresMetrics2025,
  title = {Understanding Measures and Metrics | {{SonarQube Server Documentation}}},
  author = {SonarQube},
  date = {2025},
  url = {https://docs.sonarsource.com/sonarqube-server/latest/user-guide/code-metrics/metrics-definition/},
  urldate = {2025-03-19},
  abstract = {This section describes the metrics used in the Sonar solution to evaluate your code.},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\CJDA324G\metrics-definition.html}
}

@book{taylorSoftwareArchitectureFoundations2009,
  title = {Software {{Architecture}}: {{Foundations}}, {{Theory}}, and {{Practice}}},
  shorttitle = {Software {{Architecture}}},
  author = {Taylor, R. N. and Medvidovic, N. and Dashofy, E. M.},
  date = {2009},
  publisher = {Wiley Publishing},
  abstract = {Software architecture is foundational to the development of large, practical software-intensive applications. This brand-new text covers all facets of software architecture and how it serves as the intellectual centerpiece of software development and evolution. Critically, this text focuses on supporting creation of real implemented systems. Hence the text details not only modeling techniques, but design, implementation, deployment, and system adaptation -- as well as a host of other topics -- putting the elements in context and comparing and contrasting them with one another. Rather than focusing on one method, notation, tool, or process, this new text/reference widely surveys software architecture techniques, enabling the instructor and practitioner to choose the right tool for the job at hand. Software Architecture is intended for upper-division undergraduate and graduate courses in software architecture, software design, component-based software engineering, and distributed systems; the text may also be used in introductory as well as advanced software engineering courses.},
  isbn = {978-0-470-16774-8},
  pagetotal = {750}
}

@article{TechnicalDebtMetaphor2024,
  title = {Technical {{Debt}}: {{From Metaphor}} to {{Theory}} and {{Practice}} | {{Request PDF}}},
  shorttitle = {Technical {{Debt}}},
  date = {2024-10-22},
  journaltitle = {ResearchGate},
  doi = {10.1109/MS.2012.167},
  url = {https://www.researchgate.net/publication/233813965_Technical_Debt_From_Metaphor_to_Theory_and_Practice},
  urldate = {2025-03-11},
  abstract = {Request PDF | Technical Debt: From Metaphor to Theory and Practice | The metaphor of technical debt in software development was introduced two decades ago to explain to nontechnical stakeholders the need for what we... | Find, read and cite all the research you need on ResearchGate},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\AZDXTXBJ\233813965_Technical_Debt_From_Metaphor_to_Theory_and_Practice.html}
}

@article{temperoBarriersRefactoring2017,
  title = {Barriers to Refactoring},
  shorttitle = {Barries to Refactoring},
  author = {Tempero, Ewan and Gorschek, Tony and Angelis, Lefteris},
  date = {2017-09-25},
  journaltitle = {Commun. ACM},
  volume = {60},
  number = {10},
  pages = {54--61},
  issn = {0001-0782},
  doi = {10.1145/3131873},
  url = {https://dl.acm.org/doi/10.1145/3131873},
  urldate = {2025-03-21},
  abstract = {Developers know refactoring improves their software, but many find themselves unable to do so when they want to.},
  file = {C:\Users\Karl\Zotero\storage\XF2CRZMQ\Tempero et al. - 2017 - Barriers to refactoring.pdf}
}

@inproceedings{thomasStaticDynamicArchitecture2017,
  title = {Static and {{Dynamic Architecture Conformance Checking}}: {{A Systematic}}, {{Case Study-Based Analysis}} on {{Tradeoffs}} and {{Synergies}}},
  shorttitle = {Architecture {{Conformance Checking}}},
  author = {Thomas, Jan and Dragomir, Ana Maria and Lichter, Horst},
  date = {2017-12-01},
  pages = {13},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\4VLG4XKL\\Thomas et al. - 2017 - Static and Dynamic Architecture Conformance Checking A Systematic, Case Study-Based Analysis on Tra.pdf;C\:\\Users\\Karl\\Zotero\\storage\\W452PFQP\\Thomas et al. - 2017 - Static and Dynamic Architecture Conformance Checking A Systematic, Case Study-Based Analysis on Tra.pdf}
}

@article{una-mayoreillyanderikhemberg.OvercomingCodeRot2018,
  title = {Overcoming Code Rot in Legacy Software Projects},
  author = {{Una-May O'reilly and Erik Hemberg.} and {Massachusetts Institute of Technology. Department of Electrical Engineering and Computer Science.} and Liew, Austin Jun-Yian},
  date = {2018-01-01},
  url = {https://research.ebsco.com/linkprocessor/plink?id=9648374b-37d5-3a32-b40f-b57737464800},
  abstract = {Thesis: M. Eng., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2017.},
  langid = {english},
  file = {C:\Users\Karl\Zotero\storage\7XDB39QP\Una-May O'reilly and Erik Hemberg. et al. - 2018 - Overcoming code rot in legacy software projects.pdf}
}

@article{uzunovaQualityGatesSoftware2024,
  title = {Quality {{Gates}} in {{Software Development}}: {{Concepts}}, {{Definition}} and {{Tools}}},
  shorttitle = {Quality {{Gates}}},
  author = {Uzunova, Nadica and PavliÄ, Luka and BeraniÄ, Tina},
  date = {2024-12-03},
  file = {C:\Users\Karl\Zotero\storage\XLWWKTU3\Uzunova et al. - 2024 - Quality Gates in Software Development Concepts, Definition and Tools.pdf}
}

@article{vangurpDesignErosionProblems2002,
  title = {Design Erosion: Problems and Causes},
  shorttitle = {Design Erosion},
  author = {family=Gurp, given=Jilles, prefix=van, useprefix=true and Bosch, Jan},
  date = {2002-03-15},
  journaltitle = {Journal of Systems and Software},
  shortjournal = {Journal of Systems and Software},
  volume = {61},
  number = {2},
  pages = {105--119},
  issn = {0164-1212},
  doi = {10.1016/S0164-1212(01)00152-2},
  url = {https://www.sciencedirect.com/science/article/pii/S0164121201001522},
  urldate = {2025-02-07},
  abstract = {Design erosion is a common problem in software engineering. We have found that invariably, no matter how ambitious the intentions of the designers were, software designs tend to erode over time to the point that redesigning from scratch becomes a viable alternative compared to prolonging the life of the existing design. In this paper, we illustrate how design erosion works by presenting the evolution of the design of a small software system. In our analysis of this example, we show how design decisions accumulate and become invalid because of new requirements. Also it is argued that even an optimal strategy for designing the system (i.e. no compromises with respect to e.g. cost are made) does not lead to an optimal design because of unforeseen requirement changes that invalidate design decisions that were once optimal.},
  file = {C:\Users\Karl\Zotero\storage\ZVLMARKG\S0164121201001522.html}
}

@online{VModellXT,
  title = {V-Modell XT},
  url = {https://www.cio.bund.de/Webs/CIO/DE/digitaler-wandel/Achitekturen_und_Standards/V_modell_xt/v_modell_xt-artikel.html?nn=18713562},
  urldate = {2025-02-11},
  abstract = {FÃ¼r komplexe und innovative Softwareentwicklung braucht es einen Standard, der strukturiertes Vorgehen mit flexiblen Vorgehensbausteinen kombiniert. Das V-Modell Â® XT bietet genau das in Form einer anpassbaren Struktur sowie vorgegebener Rollen, Produkte (Ergebnisse) und AblÃ¤ufe, die die Orientierung im Projekt erleichtern.},
  langid = {ngerman},
  organization = {Der Beauftragte der Bundesregierung fÃ¼r Informationstechnik},
  file = {C\:\\Users\\Karl\\Zotero\\storage\\63I5MFYW\\V-Modell XT.pdf;C\:\\Users\\Karl\\Zotero\\storage\\JWZ7IBGS\\v_modell_xt-node.html}
}
